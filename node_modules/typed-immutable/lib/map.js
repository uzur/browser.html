(function (factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "./typed", "immutable"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("./typed"), require("immutable"));
  }
})(function (exports, _typed, _immutable) {
  "use strict";

  var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

  var _defineProperty = function (obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); };

  var _createComputedClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var prop = props[i]; prop.configurable = true; if (prop.value) prop.writable = true; Object.defineProperty(target, prop.key, prop); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

  var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

  var Typed = _typed.Typed;
  var Type = _typed.Type;
  var Union = _typed.Union;
  var Any = _typed.Any;
  var typeOf = _typed.typeOf;
  var construct = _typed.construct;
  var Immutable = _immutable;

  var ImmutableMap = Immutable.Map;
  var Keyed = Immutable.Iterable.Keyed;

  var $store = Typed.store;
  var $type = Typed.type;
  var $read = Typed.read;
  var $step = Typed.step;
  var $init = Typed.init;
  var $result = Typed.result;
  var $label = Typed.label;
  var $typeName = Typed.typeName;
  var $empty = Typed.empty;

  var EntryType = (function (_Type) {
    function EntryType(key, value, label) {
      _classCallCheck(this, EntryType);

      this.key = key;
      this.value = value;
      this.label = label;
    }

    _inherits(EntryType, _Type);

    _createComputedClass(EntryType, [{
      key: Typed.typeName,
      value: function () {
        return this.label || "" + this.key[$typeName]() + ", " + this.value[$typeName]();
      }
    }, {
      key: Typed.read,
      value: function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2);

        var key = _ref2[0];
        var value = _ref2[1];

        var keyResult = this.key[$read](key);
        if (keyResult instanceof TypeError) {
          return TypeError("Invalid key: " + keyResult.message);
        }

        var valueResult = this.value[$read](value);
        if (valueResult instanceof TypeError) {
          return TypeError("Invalid value: " + valueResult.message);
        }

        return [keyResult, valueResult];
      }
    }]);

    return EntryType;
  })(Type);

  var InferredEntryType = (function (_EntryType) {
    function InferredEntryType() {
      _classCallCheck(this, InferredEntryType);

      this.key = null;
      this.value = null;
    }

    _inherits(InferredEntryType, _EntryType);

    _createComputedClass(InferredEntryType, [{
      key: "toStatic",
      value: function toStatic() {
        return new MapEntryType(this.key, this.value);
      }
    }, {
      key: Typed.typeName,
      value: function () {
        var key = this.key ? this.key[$typeName]() : "TypeInferred";
        var value = this.value ? this.value[$typeName]() : "TypeInferred";
        return "" + key + ", " + value;
      }
    }, {
      key: Typed.read,
      value: function (entry) {
        // typeOf usually creates type for the value with that
        // value being a default. For type inference we should
        // actually use a base type instead of type with default
        // there for we use prototype of the constructor.
        var key = typeOf(entry[0]).constructor.prototype;
        this.key = this.key ? Union(this.key, key) : key;

        var value = typeOf(entry[1]).constructor.prototype;
        this.value = this.value ? Union(this.value, value) : value;

        return entry;
      }
    }]);

    return InferredEntryType;
  })(EntryType);

  var TypedMap = (function (_Immutable$Map) {
    function TypedMap(value) {
      _classCallCheck(this, TypedMap);

      return TypedMap.prototype[$read](value);
    }

    _inherits(TypedMap, _Immutable$Map);

    _createComputedClass(TypedMap, [{
      key: "advance",
      value: function advance(store) {
        var result = store.__ownerID ? this : construct(this);
        result[$store] = store;
        result.size = store.size;
        result.__ownerID = store.__ownerID;
        return result;
      }
    }, {
      key: Typed.init,
      value: function () {
        return this.advance(ImmutableMap()).asMutable();
      }
    }, {
      key: Typed.step,
      value: function (state, entry) {
        var result = this[$type][$read](entry);

        if (result instanceof TypeError) {
          throw result;
        }

        var _result = _slicedToArray(result, 2);

        var key = _result[0];
        var value = _result[1];

        return state.advance(state[$store].set(key, value));
      }
    }, {
      key: Typed.result,
      value: function (state) {
        return state.asImmutable();
      }
    }, {
      key: Typed.read,
      value: function (structure) {
        var constructor = this.constructor;

        if (structure === null || structure === void 0) {
          if (!this[$empty]) {
            this[$empty] = this.advance(ImmutableMap());
          }

          return this[$empty];
        }

        var isInstance = structure instanceof constructor && structure.constructor === constructor;

        if (isInstance) {
          return structure;
        }

        var entries = Keyed(structure).entries();
        var type = this[$type];
        var state = this[$init]();

        while (true) {
          var _entries$next = entries.next();

          var done = _entries$next.done;
          var entry = _entries$next.value;

          if (done) {
            break;
          }

          var result = type[$read](entry);

          if (result instanceof TypeError) {
            return result;
          }

          state = state[$step](state, result);
        }

        return this[$result](state);
      }
    }, {
      key: Typed.typeName,
      value: function () {
        return this[$label] || "Typed.Map(" + this[$type][$typeName]() + ")";
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.__toString(this[$typeName]() + "({", "})");
      }
    }, {
      key: "has",
      value: function has(key) {
        return this[$store].has(key);
      }
    }, {
      key: "get",
      value: function get(key, fallback) {
        return this[$store].get(key, fallback);
      }
    }, {
      key: "clear",
      value: function clear() {
        if (this.size === 0) {
          return this;
        }

        if (this.__ownerID) {
          return this.advance(this[$store].clear());
        }

        return this[$empty] || this[$read]();
      }
    }, {
      key: "remove",
      value: function remove(key) {
        return this.advance(this[$store].remove(key));
      }
    }, {
      key: "set",
      value: function set(key, value) {
        return this[$step](this, [key, value]);
      }
    }, {
      key: "wasAltered",
      value: function wasAltered() {
        return this[$store].wasAltered();
      }
    }, {
      key: "__ensureOwner",
      value: function __ensureOwner(ownerID) {
        var result = this.__ownerID === ownerID ? this : !ownerID ? this : construct(this);

        var store = this[$store].__ensureOwner(ownerID);
        result[$store] = store;
        result.size = store.size;
        result.__ownerID = ownerID;

        return result;
      }
    }, {
      key: "__iterator",
      value: function __iterator(type, reverse) {
        this[$store].__iterator(type, reverse);
      }
    }, {
      key: "__iterate",
      value: function __iterate(f, reverse) {
        this[$store].__iterate(f, reverse);
      }
    }]);

    return TypedMap;
  })(Immutable.Map);

  TypedMap.prototype[Typed.DELETE] = TypedMap.prototype.remove;

  var TypeInferredMap = (function (_TypedMap) {
    function TypeInferredMap() {
      _classCallCheck(this, TypeInferredMap);
    }

    _inherits(TypeInferredMap, _TypedMap);

    _createComputedClass(TypeInferredMap, [{
      key: Typed.init,
      value: function () {
        var result = this.advance(ImmutableMap()).asMutable();
        result[$type] = new InferredEntryType();
        return result;
      }
    }, {
      key: Typed.result,
      value: function (state) {
        var result = state.asImmutable();
        result[$type] = state[$type].toStatic();

        return result;
      }
    }]);

    return TypeInferredMap;
  })(TypedMap);

  var Map = function Map(keyDescriptor, valueDescriptor, label) {
    if (keyDescriptor === void 0) {
      throw TypeError("Typed.Map must be passed a key type descriptor");
    }

    if (valueDescriptor === void 0) {
      throw TypeError("Typed.Map must be passed a value type descriptor");
    }

    // If both key and value types are Any this is just a plain immutable map.
    if (keyDescriptor === Any && valueDescriptor === Any) {
      return ImmutableMap;
    }

    var keyType = typeOf(keyDescriptor);
    var valueType = typeOf(valueDescriptor);

    if (keyType === Any && keyDescriptor !== Any) {
      throw TypeError("Typed.Map was passed an invalid key type descriptor: " + keyDescriptor);
    }

    if (valueType === Any && valueDescriptor !== Any) {
      throw TypeError("Typed.Map was passed an invalid value type descriptor: " + valueDescriptor);
    }

    var type = new EntryType(keyType, valueType, label);

    var MapType = (function (_MapType) {
      var _MapTypeWrapper = function MapType(_x) {
        return _MapType.apply(this, arguments);
      };

      _MapTypeWrapper.toString = function () {
        return _MapType.toString();
      };

      return _MapTypeWrapper;
    })(function (value) {
      var isThis = this instanceof MapType;
      var constructor = isThis ? this.constructor : MapType;

      if (value instanceof constructor) {
        return value;
      }

      var result = constructor.prototype[$read](value);

      if (result instanceof TypeError) {
        throw result;
      }

      var isCall = isThis && construct.prototype === this;

      if (!isCall && isThis) {
        this[$store] = result[$store];
        this.size = result.size;
      } else {
        return result;
      }

      return this;
    });
    MapType.prototype = Object.create(MapPrototype, (function () {
      var _Object$create = {
        constructor: { value: MapType } };

      _defineProperty(_Object$create, $type, { value: type });

      _defineProperty(_Object$create, $label, { value: label });

      return _Object$create;
    })());

    return MapType;
  };
  exports.Map = Map;
  Map.Type = TypedMap;
  Map.prototype = TypedMap.prototype;
  var MapPrototype = Map.prototype;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9tYXAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQUFRLEtBQUssVUFBTCxLQUFLO01BQUUsSUFBSSxVQUFKLElBQUk7TUFBRSxLQUFLLFVBQUwsS0FBSztNQUFFLEdBQUcsVUFBSCxHQUFHO01BQUUsTUFBTSxVQUFOLE1BQU07TUFBRSxTQUFTLFVBQVQsU0FBUztNQUN0QyxTQUFTOztBQUdyQixNQUFNLFlBQVksR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFBO01BQzNCLEtBQUssR0FBSSxTQUFTLENBQUMsUUFBUSxDQUEzQixLQUFLOztBQUVaLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUE7QUFDMUIsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQTtBQUN4QixNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFBO0FBQ3hCLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUE7QUFDeEIsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQTtBQUN4QixNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFBO0FBQzVCLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUE7QUFDMUIsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQTtBQUNoQyxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFBOztNQUVwQixTQUFTO0FBQ0YsYUFEUCxTQUFTLENBQ0QsR0FBRyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7NEJBRDNCLFNBQVM7O0FBRVgsVUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUE7QUFDZCxVQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQTtBQUNsQixVQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQTtLQUNuQjs7Y0FMRyxTQUFTOzt5QkFBVCxTQUFTO1dBTVosS0FBSyxDQUFDLFFBQVE7YUFBQyxZQUFHO0FBQ2pCLGVBQU8sSUFBSSxDQUFDLEtBQUssU0FDUCxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxFQUFFLFVBQUssSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRSxBQUFFLENBQUE7T0FDOUQ7O1dBQ0EsS0FBSyxDQUFDLElBQUk7YUFBQyxnQkFBZTs7O1lBQWIsR0FBRztZQUFFLEtBQUs7O0FBQ3RCLFlBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUE7QUFDdEMsWUFBSSxTQUFTLFlBQVksU0FBUyxFQUFFO0FBQ2xDLGlCQUFPLFNBQVMsbUJBQWlCLFNBQVMsQ0FBQyxPQUFPLENBQUcsQ0FBQTtTQUN0RDs7QUFFRCxZQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQzVDLFlBQUksV0FBVyxZQUFZLFNBQVMsRUFBRTtBQUNwQyxpQkFBTyxTQUFTLHFCQUFtQixXQUFXLENBQUMsT0FBTyxDQUFHLENBQUE7U0FDMUQ7O0FBRUQsZUFBTyxDQUFDLFNBQVMsRUFBRSxXQUFXLENBQUMsQ0FBQTtPQUNoQzs7O1dBdEJHLFNBQVM7S0FBUyxJQUFJOztNQXlCdEIsaUJBQWlCO0FBQ1YsYUFEUCxpQkFBaUIsR0FDUDs0QkFEVixpQkFBaUI7O0FBRW5CLFVBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFBO0FBQ2YsVUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUE7S0FDbEI7O2NBSkcsaUJBQWlCOzt5QkFBakIsaUJBQWlCOzthQUtiLG9CQUFHO0FBQ1QsZUFBTyxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQTtPQUM5Qzs7V0FDQSxLQUFLLENBQUMsUUFBUTthQUFDLFlBQUc7QUFDakIsWUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxFQUFFLEdBQUcsY0FBYyxDQUFBO0FBQzdELFlBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHLGNBQWMsQ0FBQTtBQUNuRSxvQkFBVSxHQUFHLFVBQUssS0FBSyxDQUFFO09BQzFCOztXQUNBLEtBQUssQ0FBQyxJQUFJO2FBQUMsVUFBQyxLQUFLLEVBQUU7Ozs7O0FBS2xCLFlBQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFBO0FBQ2xELFlBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUE7O0FBRWhELFlBQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFBO0FBQ3BELFlBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUE7O0FBRTFELGVBQU8sS0FBSyxDQUFBO09BQ2I7OztXQXpCRyxpQkFBaUI7S0FBUyxTQUFTOztNQTRCbkMsUUFBUTtBQUNELGFBRFAsUUFBUSxDQUNBLEtBQUssRUFBRTs0QkFEZixRQUFROztBQUVWLGFBQU8sUUFBUSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtLQUN4Qzs7Y0FIRyxRQUFROzt5QkFBUixRQUFROzthQUlMLGlCQUFDLEtBQUssRUFBRTtBQUNiLFlBQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxTQUFTLEdBQUcsSUFBSSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUN2RCxjQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFBO0FBQ3RCLGNBQU0sQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQTtBQUN4QixjQUFNLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUE7QUFDbEMsZUFBTyxNQUFNLENBQUE7T0FDZDs7V0FDQSxLQUFLLENBQUMsSUFBSTthQUFDLFlBQUc7QUFDYixlQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQTtPQUNoRDs7V0FDQSxLQUFLLENBQUMsSUFBSTthQUFDLFVBQUMsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUN6QixZQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUE7O0FBRXhDLFlBQUksTUFBTSxZQUFZLFNBQVMsRUFBRTtBQUMvQixnQkFBTSxNQUFNLENBQUE7U0FDYjs7cUNBRW9CLE1BQU07O1lBQXBCLEdBQUc7WUFBRSxLQUFLOztBQUNqQixlQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQTtPQUNwRDs7V0FDQSxLQUFLLENBQUMsTUFBTTthQUFDLFVBQUMsS0FBSyxFQUFFO0FBQ3BCLGVBQU8sS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFBO09BQzNCOztXQUVBLEtBQUssQ0FBQyxJQUFJO2FBQUMsVUFBQyxTQUFTLEVBQUU7QUFDdEIsWUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQTs7QUFFcEMsWUFBSSxTQUFTLEtBQUssSUFBSSxJQUFJLFNBQVMsS0FBSyxLQUFLLENBQUMsQUFBQyxFQUFFO0FBQy9DLGNBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFDakIsZ0JBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUE7V0FDNUM7O0FBRUQsaUJBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1NBQ3BCOztBQUVELFlBQU0sVUFBVSxHQUFHLFNBQVMsWUFBWSxXQUFXLElBQ2hDLFNBQVMsQ0FBQyxXQUFXLEtBQUssV0FBVyxDQUFBOztBQUV4RCxZQUFJLFVBQVUsRUFBRTtBQUNkLGlCQUFPLFNBQVMsQ0FBQTtTQUNqQjs7QUFHRCxZQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUE7QUFDMUMsWUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQ3hCLFlBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFBOztBQUV6QixlQUFPLElBQUksRUFBRTs4QkFDa0IsT0FBTyxDQUFDLElBQUksRUFBRTs7Y0FBcEMsSUFBSSxpQkFBSixJQUFJO2NBQVMsS0FBSyxpQkFBWixLQUFLOztBQUVsQixjQUFJLElBQUksRUFBRTtBQUNSLGtCQUFLO1dBQ047O0FBRUQsY0FBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFBOztBQUVqQyxjQUFJLE1BQU0sWUFBWSxTQUFTLEVBQUU7QUFDL0IsbUJBQU8sTUFBTSxDQUFBO1dBQ2Q7O0FBRUQsZUFBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUE7U0FDcEM7O0FBRUQsZUFBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUE7T0FDNUI7O1dBRUEsS0FBSyxDQUFDLFFBQVE7YUFBQyxZQUFHO0FBQ2pCLGVBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxtQkFBaUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFFLE1BQUcsQ0FBQTtPQUNoRTs7O2FBRU8sb0JBQUc7QUFDVCxlQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFBO09BQ3ZEOzs7YUFFRSxhQUFDLEdBQUcsRUFBRTtBQUNQLGVBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQTtPQUM3Qjs7O2FBRUUsYUFBQyxHQUFHLEVBQUUsUUFBUSxFQUFFO0FBQ2pCLGVBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUE7T0FDdkM7OzthQUVJLGlCQUFHO0FBQ04sWUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtBQUNuQixpQkFBTyxJQUFJLENBQUE7U0FDWjs7QUFFRCxZQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7QUFDbEIsaUJBQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQTtTQUMxQzs7QUFFRCxlQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQTtPQUNyQzs7O2FBRUssZ0JBQUMsR0FBRyxFQUFFO0FBQ1YsZUFBTyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtPQUM5Qzs7O2FBRUUsYUFBQyxHQUFHLEVBQUUsS0FBSyxFQUFFO0FBQ2QsZUFBTyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUE7T0FDdkM7OzthQUVTLHNCQUFHO0FBQ1gsZUFBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUE7T0FDakM7OzthQUVZLHVCQUFDLE9BQU8sRUFBRTtBQUNyQixZQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxLQUFLLE9BQU8sR0FBRyxJQUFJLEdBQ2pDLENBQUMsT0FBTyxHQUFHLElBQUksR0FDZixTQUFTLENBQUMsSUFBSSxDQUFDLENBQUE7O0FBRTlCLFlBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUE7QUFDakQsY0FBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQTtBQUN0QixjQUFNLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUE7QUFDeEIsY0FBTSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUE7O0FBRTFCLGVBQU8sTUFBTSxDQUFBO09BQ2Q7OzthQUNTLG9CQUFDLElBQUksRUFBRSxPQUFPLEVBQUU7QUFDeEIsWUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUE7T0FDdkM7OzthQUVRLG1CQUFDLENBQUMsRUFBRSxPQUFPLEVBQUU7QUFDcEIsWUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUE7T0FDbkM7OztXQWhJRyxRQUFRO0tBQVMsU0FBUyxDQUFDLEdBQUc7O0FBa0lwQyxVQUFRLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQTs7TUFFdEQsZUFBZTtBQUNSLGFBRFAsZUFBZSxHQUNMOzRCQURWLGVBQWU7S0FDSDs7Y0FEWixlQUFlOzt5QkFBZixlQUFlO1dBRWxCLEtBQUssQ0FBQyxJQUFJO2FBQUMsWUFBRztBQUNiLFlBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQTtBQUN2RCxjQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxpQkFBaUIsRUFBRSxDQUFBO0FBQ3ZDLGVBQU8sTUFBTSxDQUFBO09BQ2Q7O1dBQ0EsS0FBSyxDQUFDLE1BQU07YUFBQyxVQUFDLEtBQUssRUFBRTtBQUNwQixZQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUE7QUFDbEMsY0FBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQTs7QUFFdkMsZUFBTyxNQUFNLENBQUE7T0FDZDs7O1dBWkcsZUFBZTtLQUFTLFFBQVE7O0FBZS9CLE1BQU0sR0FBRyxHQUFHLGFBQVMsYUFBYSxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUU7QUFDakUsUUFBSSxhQUFhLEtBQUssS0FBSyxDQUFDLEFBQUMsRUFBRTtBQUM3QixZQUFNLFNBQVMsQ0FBQyxnREFBZ0QsQ0FBQyxDQUFBO0tBQ2xFOztBQUVELFFBQUksZUFBZSxLQUFLLEtBQUssQ0FBQyxBQUFDLEVBQUU7QUFDL0IsWUFBTSxTQUFTLENBQUMsa0RBQWtELENBQUMsQ0FBQTtLQUNwRTs7O0FBR0QsUUFBSSxhQUFhLEtBQUssR0FBRyxJQUFJLGVBQWUsS0FBSyxHQUFHLEVBQUU7QUFDcEQsYUFBTyxZQUFZLENBQUE7S0FDcEI7O0FBRUQsUUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFBO0FBQ3JDLFFBQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQTs7QUFFekMsUUFBSSxPQUFPLEtBQUssR0FBRyxJQUFJLGFBQWEsS0FBSyxHQUFHLEVBQUU7QUFDNUMsWUFBTSxTQUFTLDJEQUF5RCxhQUFhLENBQUcsQ0FBQTtLQUN6Rjs7QUFFRCxRQUFJLFNBQVMsS0FBSyxHQUFHLElBQUksZUFBZSxLQUFLLEdBQUcsRUFBRTtBQUNoRCxZQUFNLFNBQVMsNkRBQTJELGVBQWUsQ0FBRyxDQUFBO0tBQzdGOztBQUVELFFBQU0sSUFBSSxHQUFHLElBQUksU0FBUyxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUE7O0FBRXJELFFBQU0sT0FBTzs7Ozs7Ozs7OztPQUFHLFVBQVMsS0FBSyxFQUFFO0FBQzlCLFVBQU0sTUFBTSxHQUFHLElBQUksWUFBWSxPQUFPLENBQUE7QUFDdEMsVUFBTSxXQUFXLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFBOztBQUV2RCxVQUFJLEtBQUssWUFBWSxXQUFXLEVBQUU7QUFDaEMsZUFBTyxLQUFLLENBQUE7T0FDYjs7QUFFRCxVQUFNLE1BQU0sR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFBOztBQUVsRCxVQUFJLE1BQU0sWUFBWSxTQUFTLEVBQUU7QUFDL0IsY0FBTSxNQUFNLENBQUE7T0FDYjs7QUFFRCxVQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksU0FBUyxDQUFDLFNBQVMsS0FBSyxJQUFJLENBQUE7O0FBRXJELFVBQUksQ0FBQyxNQUFNLElBQUksTUFBTSxFQUFFO0FBQ3JCLFlBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUE7QUFDN0IsWUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFBO09BQ3hCLE1BQU07QUFDTCxlQUFPLE1BQU0sQ0FBQTtPQUNkOztBQUVELGFBQU8sSUFBSSxDQUFBO0tBQ1osQ0FBQSxDQUFBO0FBQ0QsV0FBTyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLFlBQVk7O0FBQzVDLHFCQUFhLEVBQUMsS0FBSyxFQUFFLE9BQU8sRUFBQzs7c0NBQzVCLEtBQUssRUFBRyxFQUFDLEtBQUssRUFBRSxJQUFJLEVBQUM7O3NDQUNyQixNQUFNLEVBQUcsRUFBQyxLQUFLLEVBQUUsS0FBSyxFQUFDOzs7U0FDeEIsQ0FBQTs7QUFFRixXQUFPLE9BQU8sQ0FBQTtHQUNmLENBQUE7VUEzRFksR0FBRyxHQUFILEdBQUc7QUE0RGhCLEtBQUcsQ0FBQyxJQUFJLEdBQUcsUUFBUSxDQUFBO0FBQ25CLEtBQUcsQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQTtBQUNsQyxNQUFNLFlBQVksR0FBRyxHQUFHLENBQUMsU0FBUyxDQUFBIiwiZmlsZSI6InNyYy9tYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1R5cGVkLCBUeXBlLCBVbmlvbiwgQW55LCB0eXBlT2YsIGNvbnN0cnVjdH0gZnJvbSBcIi4vdHlwZWRcIlxuaW1wb3J0ICogYXMgSW1tdXRhYmxlIGZyb20gJ2ltbXV0YWJsZSdcblxuXG5jb25zdCBJbW11dGFibGVNYXAgPSBJbW11dGFibGUuTWFwXG5jb25zdCB7S2V5ZWR9ID0gSW1tdXRhYmxlLkl0ZXJhYmxlXG5cbmNvbnN0ICRzdG9yZSA9IFR5cGVkLnN0b3JlXG5jb25zdCAkdHlwZSA9IFR5cGVkLnR5cGVcbmNvbnN0ICRyZWFkID0gVHlwZWQucmVhZFxuY29uc3QgJHN0ZXAgPSBUeXBlZC5zdGVwXG5jb25zdCAkaW5pdCA9IFR5cGVkLmluaXRcbmNvbnN0ICRyZXN1bHQgPSBUeXBlZC5yZXN1bHRcbmNvbnN0ICRsYWJlbCA9IFR5cGVkLmxhYmVsXG5jb25zdCAkdHlwZU5hbWUgPSBUeXBlZC50eXBlTmFtZVxuY29uc3QgJGVtcHR5ID0gVHlwZWQuZW1wdHlcblxuY2xhc3MgRW50cnlUeXBlIGV4dGVuZHMgVHlwZSB7XG4gIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIGxhYmVsKSB7XG4gICAgdGhpcy5rZXkgPSBrZXlcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLmxhYmVsID0gbGFiZWxcbiAgfVxuICBbVHlwZWQudHlwZU5hbWVdKCkge1xuICAgIHJldHVybiB0aGlzLmxhYmVsIHx8XG4gICAgICAgICAgIGAke3RoaXMua2V5WyR0eXBlTmFtZV0oKX0sICR7dGhpcy52YWx1ZVskdHlwZU5hbWVdKCl9YFxuICB9XG4gIFtUeXBlZC5yZWFkXShba2V5LCB2YWx1ZV0pIHtcbiAgICBjb25zdCBrZXlSZXN1bHQgPSB0aGlzLmtleVskcmVhZF0oa2V5KVxuICAgIGlmIChrZXlSZXN1bHQgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgIHJldHVybiBUeXBlRXJyb3IoYEludmFsaWQga2V5OiAke2tleVJlc3VsdC5tZXNzYWdlfWApXG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWVSZXN1bHQgPSB0aGlzLnZhbHVlWyRyZWFkXSh2YWx1ZSlcbiAgICBpZiAodmFsdWVSZXN1bHQgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgIHJldHVybiBUeXBlRXJyb3IoYEludmFsaWQgdmFsdWU6ICR7dmFsdWVSZXN1bHQubWVzc2FnZX1gKVxuICAgIH1cblxuICAgIHJldHVybiBba2V5UmVzdWx0LCB2YWx1ZVJlc3VsdF1cbiAgfVxufVxuXG5jbGFzcyBJbmZlcnJlZEVudHJ5VHlwZSBleHRlbmRzIEVudHJ5VHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMua2V5ID0gbnVsbFxuICAgIHRoaXMudmFsdWUgPSBudWxsXG4gIH1cbiAgdG9TdGF0aWMoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXBFbnRyeVR5cGUodGhpcy5rZXksIHRoaXMudmFsdWUpXG4gIH1cbiAgW1R5cGVkLnR5cGVOYW1lXSgpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmtleSA/IHRoaXMua2V5WyR0eXBlTmFtZV0oKSA6IFwiVHlwZUluZmVycmVkXCJcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlWyR0eXBlTmFtZV0oKSA6IFwiVHlwZUluZmVycmVkXCJcbiAgICByZXR1cm4gYCR7a2V5fSwgJHt2YWx1ZX1gXG4gIH1cbiAgW1R5cGVkLnJlYWRdKGVudHJ5KSB7XG4gICAgLy8gdHlwZU9mIHVzdWFsbHkgY3JlYXRlcyB0eXBlIGZvciB0aGUgdmFsdWUgd2l0aCB0aGF0XG4gICAgLy8gdmFsdWUgYmVpbmcgYSBkZWZhdWx0LiBGb3IgdHlwZSBpbmZlcmVuY2Ugd2Ugc2hvdWxkXG4gICAgLy8gYWN0dWFsbHkgdXNlIGEgYmFzZSB0eXBlIGluc3RlYWQgb2YgdHlwZSB3aXRoIGRlZmF1bHRcbiAgICAvLyB0aGVyZSBmb3Igd2UgdXNlIHByb3RvdHlwZSBvZiB0aGUgY29uc3RydWN0b3IuXG4gICAgY29uc3Qga2V5ID0gdHlwZU9mKGVudHJ5WzBdKS5jb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgICB0aGlzLmtleSA9IHRoaXMua2V5ID8gVW5pb24odGhpcy5rZXksIGtleSkgOiBrZXlcblxuICAgIGNvbnN0IHZhbHVlID0gdHlwZU9mKGVudHJ5WzFdKS5jb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZSA/IFVuaW9uKHRoaXMudmFsdWUsIHZhbHVlKSA6IHZhbHVlXG5cbiAgICByZXR1cm4gZW50cnlcbiAgfVxufVxuXG5jbGFzcyBUeXBlZE1hcCBleHRlbmRzIEltbXV0YWJsZS5NYXAge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHJldHVybiBUeXBlZE1hcC5wcm90b3R5cGVbJHJlYWRdKHZhbHVlKVxuICB9XG4gIGFkdmFuY2Uoc3RvcmUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdG9yZS5fX293bmVySUQgPyB0aGlzIDogY29uc3RydWN0KHRoaXMpXG4gICAgcmVzdWx0WyRzdG9yZV0gPSBzdG9yZVxuICAgIHJlc3VsdC5zaXplID0gc3RvcmUuc2l6ZVxuICAgIHJlc3VsdC5fX293bmVySUQgPSBzdG9yZS5fX293bmVySURcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbiAgW1R5cGVkLmluaXRdKCkge1xuICAgIHJldHVybiB0aGlzLmFkdmFuY2UoSW1tdXRhYmxlTWFwKCkpLmFzTXV0YWJsZSgpXG4gIH1cbiAgW1R5cGVkLnN0ZXBdKHN0YXRlLCBlbnRyeSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXNbJHR5cGVdWyRyZWFkXShlbnRyeSlcblxuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgIHRocm93IHJlc3VsdFxuICAgIH1cblxuICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHJlc3VsdFxuICAgIHJldHVybiBzdGF0ZS5hZHZhbmNlKHN0YXRlWyRzdG9yZV0uc2V0KGtleSwgdmFsdWUpKVxuICB9XG4gIFtUeXBlZC5yZXN1bHRdKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmFzSW1tdXRhYmxlKClcbiAgfVxuXG4gIFtUeXBlZC5yZWFkXShzdHJ1Y3R1cmUpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3JcblxuICAgIGlmIChzdHJ1Y3R1cmUgPT09IG51bGwgfHwgc3RydWN0dXJlID09PSB2b2lkKDApKSB7XG4gICAgICBpZiAoIXRoaXNbJGVtcHR5XSkge1xuICAgICAgICB0aGlzWyRlbXB0eV0gPSB0aGlzLmFkdmFuY2UoSW1tdXRhYmxlTWFwKCkpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzWyRlbXB0eV1cbiAgICB9XG5cbiAgICBjb25zdCBpc0luc3RhbmNlID0gc3RydWN0dXJlIGluc3RhbmNlb2YgY29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0dXJlLmNvbnN0cnVjdG9yID09PSBjb25zdHJ1Y3RvclxuXG4gICAgaWYgKGlzSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBzdHJ1Y3R1cmVcbiAgICB9XG5cblxuICAgIGNvbnN0IGVudHJpZXMgPSBLZXllZChzdHJ1Y3R1cmUpLmVudHJpZXMoKVxuICAgIGNvbnN0IHR5cGUgPSB0aGlzWyR0eXBlXVxuICAgIGxldCBzdGF0ZSA9IHRoaXNbJGluaXRdKClcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7ZG9uZSwgdmFsdWU6IGVudHJ5fSA9IGVudHJpZXMubmV4dCgpXG5cbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHR5cGVbJHJlYWRdKGVudHJ5KVxuXG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cblxuICAgICAgc3RhdGUgPSBzdGF0ZVskc3RlcF0oc3RhdGUsIHJlc3VsdClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1skcmVzdWx0XShzdGF0ZSlcbiAgfVxuXG4gIFtUeXBlZC50eXBlTmFtZV0oKSB7XG4gICAgcmV0dXJuIHRoaXNbJGxhYmVsXSB8fCBgVHlwZWQuTWFwKCR7dGhpc1skdHlwZV1bJHR5cGVOYW1lXSgpfSlgXG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKHRoaXNbJHR5cGVOYW1lXSgpICsgJyh7JywgJ30pJylcbiAgfVxuXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpc1skc3RvcmVdLmhhcyhrZXkpXG4gIH1cblxuICBnZXQoa2V5LCBmYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzWyRzdG9yZV0uZ2V0KGtleSwgZmFsbGJhY2spXG4gIH1cblxuICBjbGVhcigpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWR2YW5jZSh0aGlzWyRzdG9yZV0uY2xlYXIoKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1skZW1wdHldIHx8IHRoaXNbJHJlYWRdKClcbiAgfVxuXG4gIHJlbW92ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5hZHZhbmNlKHRoaXNbJHN0b3JlXS5yZW1vdmUoa2V5KSlcbiAgfVxuXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXNbJHN0ZXBdKHRoaXMsIFtrZXksIHZhbHVlXSlcbiAgfVxuXG4gIHdhc0FsdGVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXNbJHN0b3JlXS53YXNBbHRlcmVkKClcbiAgfVxuXG4gIF9fZW5zdXJlT3duZXIob3duZXJJRCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX19vd25lcklEID09PSBvd25lcklEID8gdGhpcyA6XG4gICAgICAgICAgICAgICAgICAgIW93bmVySUQgPyB0aGlzIDpcbiAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3QodGhpcylcblxuICAgIGNvbnN0IHN0b3JlID0gdGhpc1skc3RvcmVdLl9fZW5zdXJlT3duZXIob3duZXJJRClcbiAgICByZXN1bHRbJHN0b3JlXSA9IHN0b3JlXG4gICAgcmVzdWx0LnNpemUgPSBzdG9yZS5zaXplXG4gICAgcmVzdWx0Ll9fb3duZXJJRCA9IG93bmVySURcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuICBfX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpIHtcbiAgICB0aGlzWyRzdG9yZV0uX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKVxuICB9XG5cbiAgX19pdGVyYXRlKGYsIHJldmVyc2UpIHtcbiAgICB0aGlzWyRzdG9yZV0uX19pdGVyYXRlKGYsIHJldmVyc2UpXG4gIH1cbn1cblR5cGVkTWFwLnByb3RvdHlwZVtUeXBlZC5ERUxFVEVdID0gVHlwZWRNYXAucHJvdG90eXBlLnJlbW92ZVxuXG5jbGFzcyBUeXBlSW5mZXJyZWRNYXAgZXh0ZW5kcyBUeXBlZE1hcCB7XG4gIGNvbnN0cnVjdG9yKCkge31cbiAgW1R5cGVkLmluaXRdKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYWR2YW5jZShJbW11dGFibGVNYXAoKSkuYXNNdXRhYmxlKClcbiAgICByZXN1bHRbJHR5cGVdID0gbmV3IEluZmVycmVkRW50cnlUeXBlKClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbiAgW1R5cGVkLnJlc3VsdF0oc3RhdGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdGF0ZS5hc0ltbXV0YWJsZSgpXG4gICAgcmVzdWx0WyR0eXBlXSA9IHN0YXRlWyR0eXBlXS50b1N0YXRpYygpXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IE1hcCA9IGZ1bmN0aW9uKGtleURlc2NyaXB0b3IsIHZhbHVlRGVzY3JpcHRvciwgbGFiZWwpIHtcbiAgaWYgKGtleURlc2NyaXB0b3IgPT09IHZvaWQoMCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJUeXBlZC5NYXAgbXVzdCBiZSBwYXNzZWQgYSBrZXkgdHlwZSBkZXNjcmlwdG9yXCIpXG4gIH1cblxuICBpZiAodmFsdWVEZXNjcmlwdG9yID09PSB2b2lkKDApKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiVHlwZWQuTWFwIG11c3QgYmUgcGFzc2VkIGEgdmFsdWUgdHlwZSBkZXNjcmlwdG9yXCIpXG4gIH1cblxuICAvLyBJZiBib3RoIGtleSBhbmQgdmFsdWUgdHlwZXMgYXJlIEFueSB0aGlzIGlzIGp1c3QgYSBwbGFpbiBpbW11dGFibGUgbWFwLlxuICBpZiAoa2V5RGVzY3JpcHRvciA9PT0gQW55ICYmIHZhbHVlRGVzY3JpcHRvciA9PT0gQW55KSB7XG4gICAgcmV0dXJuIEltbXV0YWJsZU1hcFxuICB9XG5cbiAgY29uc3Qga2V5VHlwZSA9IHR5cGVPZihrZXlEZXNjcmlwdG9yKVxuICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlT2YodmFsdWVEZXNjcmlwdG9yKVxuXG4gIGlmIChrZXlUeXBlID09PSBBbnkgJiYga2V5RGVzY3JpcHRvciAhPT0gQW55KSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKGBUeXBlZC5NYXAgd2FzIHBhc3NlZCBhbiBpbnZhbGlkIGtleSB0eXBlIGRlc2NyaXB0b3I6ICR7a2V5RGVzY3JpcHRvcn1gKVxuICB9XG5cbiAgaWYgKHZhbHVlVHlwZSA9PT0gQW55ICYmIHZhbHVlRGVzY3JpcHRvciAhPT0gQW55KSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKGBUeXBlZC5NYXAgd2FzIHBhc3NlZCBhbiBpbnZhbGlkIHZhbHVlIHR5cGUgZGVzY3JpcHRvcjogJHt2YWx1ZURlc2NyaXB0b3J9YClcbiAgfVxuXG4gIGNvbnN0IHR5cGUgPSBuZXcgRW50cnlUeXBlKGtleVR5cGUsIHZhbHVlVHlwZSwgbGFiZWwpXG5cbiAgY29uc3QgTWFwVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgY29uc3QgaXNUaGlzID0gdGhpcyBpbnN0YW5jZW9mIE1hcFR5cGVcbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGlzVGhpcyA/IHRoaXMuY29uc3RydWN0b3IgOiBNYXBUeXBlXG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gY29uc3RydWN0b3IucHJvdG90eXBlWyRyZWFkXSh2YWx1ZSlcblxuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgIHRocm93IHJlc3VsdFxuICAgIH1cblxuICAgIGNvbnN0IGlzQ2FsbCA9IGlzVGhpcyAmJiBjb25zdHJ1Y3QucHJvdG90eXBlID09PSB0aGlzXG5cbiAgICBpZiAoIWlzQ2FsbCAmJiBpc1RoaXMpIHtcbiAgICAgIHRoaXNbJHN0b3JlXSA9IHJlc3VsdFskc3RvcmVdXG4gICAgICB0aGlzLnNpemUgPSByZXN1bHQuc2l6ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICBNYXBUeXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTWFwUHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHt2YWx1ZTogTWFwVHlwZX0sXG4gICAgWyR0eXBlXToge3ZhbHVlOiB0eXBlfSxcbiAgICBbJGxhYmVsXToge3ZhbHVlOiBsYWJlbH1cbiAgfSlcblxuICByZXR1cm4gTWFwVHlwZVxufVxuTWFwLlR5cGUgPSBUeXBlZE1hcFxuTWFwLnByb3RvdHlwZSA9IFR5cGVkTWFwLnByb3RvdHlwZVxuY29uc3QgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZVxuXG5cbiJdfQ==