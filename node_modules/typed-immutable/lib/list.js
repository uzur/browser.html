(function (factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "./typed", "immutable"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("./typed"), require("immutable"));
  }
})(function (exports, _typed, _immutable) {
  "use strict";

  var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

  var _defineProperty = function (obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); };

  var _createComputedClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var prop = props[i]; prop.configurable = true; if (prop.value) prop.writable = true; Object.defineProperty(target, prop.key, prop); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

  var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

  var Typed = _typed.Typed;
  var Type = _typed.Type;
  var Union = _typed.Union;
  var Any = _typed.Any;
  var typeOf = _typed.typeOf;
  var construct = _typed.construct;
  var Immutable = _immutable;

  var ImmutableList = Immutable.List;
  var Indexed = Immutable.Iterable.Indexed;

  var $store = Typed.store;
  var $type = Typed.type;
  var $read = Typed.read;
  var $step = Typed.step;
  var $init = Typed.init;
  var $result = Typed.result;
  var $label = Typed.label;
  var $typeName = Typed.typeName;
  var $empty = Typed.empty;

  var change = function (list, f) {
    var result = list.__ownerID ? list : construct(list);
    var store = f(list[$store]);
    result[$store] = store;
    result.size = store.size;
    return result;
  };

  var clear = function (target) {
    return target.clear();
  };
  var pop = function (target) {
    return target.pop();
  };
  var shift = function (target) {
    return target.shift();
  };

  var TypeInferer = (function (_Type) {
    function TypeInferer() {
      _classCallCheck(this, TypeInferer);

      if (_Type != null) {
        _Type.apply(this, arguments);
      }
    }

    _inherits(TypeInferer, _Type);

    _createComputedClass(TypeInferer, [{
      key: Typed.typeName,
      value: function () {
        return "TypeInferer";
      }
    }, {
      key: Typed.read,
      value: function (value) {
        // typeOf usually creates type for the value with that
        // value being a default. For type inference we should
        // actually use a base type instead of type with default
        // there for we use prototype of the constructor.
        var type = typeOf(value).constructor.prototype;
        this.type = this.type ? Union(this.type, type) : type;
        return value;
      }
    }]);

    return TypeInferer;
  })(Type);

  var TypeInferedList = (function (_Immutable$List) {
    function TypeInferedList(value) {
      _classCallCheck(this, TypeInferedList);

      return TypeInferedList.prototype[$read](value);
    }

    _inherits(TypeInferedList, _Immutable$List);

    _createComputedClass(TypeInferedList, [{
      key: Typed.init,
      value: function () {
        var result = construct(this).asMutable();
        result[$type] = new TypeInferer();
        return result;
      }
    }, {
      key: Typed.result,
      value: function (result) {
        var list = result.asImmutable();
        list[$type] = result[$type].type;

        return list;
      }
    }, {
      key: Typed.read,
      value: function (input) {
        var Type = this.constructor;

        if (input === null || input === void 0) {
          if (!Type[$empty]) {
            var result = construct(this);
            result[$store] = ImmutableList();
            result.size = 0;
            Type[$empty] = result;
          }

          return Type[$empty];
        }

        if (input instanceof Type && input.constructor === Type) {
          return input;
        }

        var list = this[$init]();
        Indexed(input).forEach(function (value, index) {
          list.set(index, value);
        });

        return this[$result](list);
      }
    }, {
      key: Typed.step,
      value: function (result, _ref) {
        var _ref2 = _slicedToArray(_ref, 2);

        var key = _ref2[0];
        var value = _ref2[1];

        return change(result, function () {
          var store = arguments[0] === undefined ? ImmutableList() : arguments[0];
          return store.set(key, value);
        });
      }
    }, {
      key: Typed.typeName,
      value: function () {
        return this[$label] || "Typed.List(" + this[$type][$typeName]() + ")";
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.__toString(this[$typeName]() + "([", "])");
      }
    }, {
      key: "has",
      value: function has(key) {
        return this[$store].has(key);
      }
    }, {
      key: "get",
      value: function get(index, notSetValue) {
        return this[$store] ? this[$store].get(index, notSetValue) : notSetValue;
      }
    }, {
      key: "clear",
      value: (function (_clear) {
        var _clearWrapper = function clear() {
          return _clear.apply(this, arguments);
        };

        _clearWrapper.toString = function () {
          return _clear.toString();
        };

        return _clearWrapper;
      })(function () {
        if (this.__ownerID) {
          return change(this, clear);
        }

        return this[$empty] || this[$read]();
      })
    }, {
      key: "remove",
      value: function remove(index) {
        return change(this, function (store) {
          return store && store.remove(index);
        });
      }
    }, {
      key: "set",
      value: function set(index, value) {
        if (index > this.size) {
          throw TypeError("Index \"" + index + "\" is out of bound");
        }

        var result = this[$type][$read](value);

        if (result instanceof TypeError) {
          throw TypeError("Invalid value: " + result.message);
        }

        return this[$step](this, [index, result]);
      }
    }, {
      key: "push",
      value: function push() {
        for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
          values[_key] = arguments[_key];
        }

        var type = this[$type];
        var items = [];
        var count = values.length;
        var index = 0;
        while (index < count) {
          var value = values[index];
          var result = type[$read](value);

          if (result instanceof TypeError) {
            throw TypeError("Invalid value: " + result.message);
          }

          items.push(result);
          index = index + 1;
        }

        return change(this, function (store) {
          return store ? store.push.apply(store, items) : ImmutableList.apply(undefined, items);
        });
      }
    }, {
      key: "pop",
      value: (function (_pop) {
        var _popWrapper = function pop() {
          return _pop.apply(this, arguments);
        };

        _popWrapper.toString = function () {
          return _pop.toString();
        };

        return _popWrapper;
      })(function () {
        return change(this, pop);
      })
    }, {
      key: "unshift",
      value: function unshift() {
        for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
          values[_key] = arguments[_key];
        }

        var type = this[$type];
        var items = [];
        var count = values.length;
        var index = 0;

        while (index < count) {
          var value = values[index];
          var result = type[$read](value);

          if (result instanceof TypeError) {
            throw TypeError("Invalid value: " + result.message);
          }

          items.push(result);
          index = index + 1;
        }

        return change(this, function (store) {
          return store ? store.unshift.apply(store, items) : ImmutableList.apply(undefined, items);
        });
      }
    }, {
      key: "shift",
      value: (function (_shift) {
        var _shiftWrapper = function shift() {
          return _shift.apply(this, arguments);
        };

        _shiftWrapper.toString = function () {
          return _shift.toString();
        };

        return _shiftWrapper;
      })(function () {
        return change(this, shift);
      })
    }, {
      key: "setSize",
      value: function setSize(size) {
        if (size > this.size) {
          throw TypeError("setSize may only downsize");
        }

        return change(this, function (store) {
          return store.setSize(size);
        });
      }
    }, {
      key: "slice",
      value: function slice(begin, end) {
        return change(this, function (store) {
          return store && store.slice(begin, end);
        });
      }
    }, {
      key: "wasAltered",
      value: function wasAltered() {
        return this[$store].wasAltered();
      }
    }, {
      key: "__ensureOwner",
      value: function __ensureOwner(ownerID) {
        var result = this.__ownerID === ownerID ? this : !ownerID ? this : construct(this);

        result.__ownerID = ownerID;
        result[$store] = this[$store] ? this[$store].__ensureOwner(ownerID) : ImmutableList().__ensureOwner(ownerID);

        return result;
      }
    }, {
      key: "__iterator",
      value: function __iterator(type, reverse) {
        var _this = this;

        return Indexed(this[$store]).map(function (_, key) {
          return _this.get(key);
        }).__iterator(type, reverse);
      }
    }, {
      key: "__iterate",
      value: function __iterate(f, reverse) {
        var _this = this;

        return Indexed(this[$store]).map(function (_, key) {
          return _this.get(key);
        }).__iterate(f, reverse);
      }
    }], [{
      key: "from",
      value: function from(list) {
        var result = construct(this.prototype);
        result[$store] = list[$store];
        return result;
      }
    }]);

    return TypeInferedList;
  })(Immutable.List);

  TypeInferedList.prototype[Typed.DELETE] = TypeInferedList.prototype.remove;

  var TypedList = (function (_TypeInferedList) {
    function TypedList() {
      _classCallCheck(this, TypedList);
    }

    _inherits(TypedList, _TypeInferedList);

    _createComputedClass(TypedList, [{
      key: Typed.init,
      value: function () {
        return construct(this).asMutable();
      }
    }, {
      key: Typed.result,
      value: function (result) {
        return result.asImmutable();
      }
    }, {
      key: "map",
      value: function map(mapper, context) {
        if (this.size === 0) {
          return this;
        } else {
          var result = TypeInferedList.from(this).map(mapper, context);
          if (result[$type] === this[$type]) {
            var list = construct(this);
            list[$store] = result[$store];
            list.size = result.size;
            return list;
          } else {
            return result;
          }
        }
      }
    }]);

    return TypedList;
  })(TypeInferedList);

  var List = function List(descriptor, label) {
    if (descriptor === void 0) {
      throw TypeError("Typed.List must be passed a type descriptor");
    }

    if (descriptor === Any) {
      return Immutable.List;
    }

    var type = typeOf(descriptor);

    if (type === Any) {
      throw TypeError("Typed.List was passed an invalid type descriptor: ${descriptor}");
    }

    var ListType = (function (_ListType) {
      var _ListTypeWrapper = function ListType(_x) {
        return _ListType.apply(this, arguments);
      };

      _ListTypeWrapper.toString = function () {
        return _ListType.toString();
      };

      return _ListTypeWrapper;
    })(function (value) {
      var isListType = this instanceof ListType;
      var Type = isListType ? this.constructor : ListType;

      if (value instanceof Type) {
        return value;
      }

      var result = Type.prototype[$read](value);

      if (result instanceof TypeError) {
        throw result;
      }

      // `list.map(f)` will in fact cause `list.constructor(items)` to be
      // invoked there for we need to check if `this[$store]` was
      // assigned to know if it's that or if it's a `new ListType()` call.
      if (isListType && !this[$store]) {
        this[$store] = result[$store];
        this.size = result.size;
      } else {
        return result;
      }

      return this;
    });
    ListType.of = ImmutableList.of;
    ListType.prototype = Object.create(ListPrototype, (function () {
      var _Object$create = {
        constructor: { value: ListType } };

      _defineProperty(_Object$create, $type, { value: type });

      _defineProperty(_Object$create, $label, { value: label });

      return _Object$create;
    })());

    return ListType;
  };
  exports.List = List;
  List.Type = TypedList;
  List.prototype = TypedList.prototype;
  var ListPrototype = TypedList.prototype;
});
//# sourceMappingURL=data:application/json;base64,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UyxDQUFBIiwiZmlsZSI6InNyYy9saXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtUeXBlZCwgVHlwZSwgVW5pb24sIEFueSwgdHlwZU9mLCBjb25zdHJ1Y3R9IGZyb20gXCIuL3R5cGVkXCJcbmltcG9ydCAqIGFzIEltbXV0YWJsZSBmcm9tICdpbW11dGFibGUnXG5cblxuY29uc3QgSW1tdXRhYmxlTGlzdCA9IEltbXV0YWJsZS5MaXN0XG5jb25zdCB7SW5kZXhlZH0gPSBJbW11dGFibGUuSXRlcmFibGVcblxuY29uc3QgJHN0b3JlID0gVHlwZWQuc3RvcmVcbmNvbnN0ICR0eXBlID0gVHlwZWQudHlwZVxuY29uc3QgJHJlYWQgPSBUeXBlZC5yZWFkXG5jb25zdCAkc3RlcCA9IFR5cGVkLnN0ZXBcbmNvbnN0ICRpbml0ID0gVHlwZWQuaW5pdFxuY29uc3QgJHJlc3VsdCA9IFR5cGVkLnJlc3VsdFxuY29uc3QgJGxhYmVsID0gVHlwZWQubGFiZWxcbmNvbnN0ICR0eXBlTmFtZSA9IFR5cGVkLnR5cGVOYW1lXG5jb25zdCAkZW1wdHkgPSBUeXBlZC5lbXB0eVxuXG5cbmNvbnN0IGNoYW5nZSA9IChsaXN0LCBmKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGxpc3QuX19vd25lcklEID8gbGlzdCA6IGNvbnN0cnVjdChsaXN0KVxuICBjb25zdCBzdG9yZSA9IGYobGlzdFskc3RvcmVdKVxuICByZXN1bHRbJHN0b3JlXSA9IHN0b3JlXG4gIHJlc3VsdC5zaXplID0gc3RvcmUuc2l6ZVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmNvbnN0IGNsZWFyID0gdGFyZ2V0ID0+IHRhcmdldC5jbGVhcigpXG5jb25zdCBwb3AgPSB0YXJnZXQgPT4gdGFyZ2V0LnBvcCgpXG5jb25zdCBzaGlmdCA9IHRhcmdldCA9PiB0YXJnZXQuc2hpZnQoKVxuXG5jbGFzcyBUeXBlSW5mZXJlciBleHRlbmRzIFR5cGUge1xuICBbVHlwZWQudHlwZU5hbWVdKCkge1xuICAgIHJldHVybiAnVHlwZUluZmVyZXInXG4gIH1cbiAgW1R5cGVkLnJlYWRdKHZhbHVlKSB7XG4gICAgLy8gdHlwZU9mIHVzdWFsbHkgY3JlYXRlcyB0eXBlIGZvciB0aGUgdmFsdWUgd2l0aCB0aGF0XG4gICAgLy8gdmFsdWUgYmVpbmcgYSBkZWZhdWx0LiBGb3IgdHlwZSBpbmZlcmVuY2Ugd2Ugc2hvdWxkXG4gICAgLy8gYWN0dWFsbHkgdXNlIGEgYmFzZSB0eXBlIGluc3RlYWQgb2YgdHlwZSB3aXRoIGRlZmF1bHRcbiAgICAvLyB0aGVyZSBmb3Igd2UgdXNlIHByb3RvdHlwZSBvZiB0aGUgY29uc3RydWN0b3IuXG4gICAgY29uc3QgdHlwZSA9IHR5cGVPZih2YWx1ZSkuY29uc3RydWN0b3IucHJvdG90eXBlXG4gICAgdGhpcy50eXBlID0gdGhpcy50eXBlID8gVW5pb24odGhpcy50eXBlLCB0eXBlKSA6IHR5cGVcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuXG5jbGFzcyBUeXBlSW5mZXJlZExpc3QgZXh0ZW5kcyBJbW11dGFibGUuTGlzdCB7XG4gIHN0YXRpYyBmcm9tKGxpc3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjb25zdHJ1Y3QodGhpcy5wcm90b3R5cGUpXG4gICAgcmVzdWx0WyRzdG9yZV0gPSBsaXN0WyRzdG9yZV1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gVHlwZUluZmVyZWRMaXN0LnByb3RvdHlwZVskcmVhZF0odmFsdWUpXG4gIH1cbiAgW1R5cGVkLmluaXRdKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGNvbnN0cnVjdCh0aGlzKS5hc011dGFibGUoKVxuICAgIHJlc3VsdFskdHlwZV0gPSBuZXcgVHlwZUluZmVyZXIoKVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuICBbVHlwZWQucmVzdWx0XShyZXN1bHQpIHtcbiAgICBjb25zdCBsaXN0ID0gcmVzdWx0LmFzSW1tdXRhYmxlKClcbiAgICBsaXN0WyR0eXBlXSA9IHJlc3VsdFskdHlwZV0udHlwZVxuXG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuXG4gIFtUeXBlZC5yZWFkXShpbnB1dCkge1xuICAgIGNvbnN0IFR5cGUgPSB0aGlzLmNvbnN0cnVjdG9yXG5cbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQoMCkpIHtcbiAgICAgIGlmICghVHlwZVskZW1wdHldKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbnN0cnVjdCh0aGlzKVxuICAgICAgICByZXN1bHRbJHN0b3JlXSA9IEltbXV0YWJsZUxpc3QoKVxuICAgICAgICByZXN1bHQuc2l6ZSA9IDBcbiAgICAgICAgVHlwZVskZW1wdHldID0gcmVzdWx0XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBUeXBlWyRlbXB0eV1cbiAgICB9XG5cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBUeXBlICYmIGlucHV0LmNvbnN0cnVjdG9yID09PSBUeXBlKSB7XG4gICAgICByZXR1cm4gaW5wdXRcbiAgICB9XG5cblxuICAgIGNvbnN0IGxpc3QgPSB0aGlzWyRpbml0XSgpXG4gICAgSW5kZXhlZChpbnB1dCkuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICBsaXN0LnNldChpbmRleCwgdmFsdWUpXG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzWyRyZXN1bHRdKGxpc3QpXG4gIH1cbiAgW1R5cGVkLnN0ZXBdKHJlc3VsdCwgW2tleSwgdmFsdWVdKSB7XG4gICAgcmV0dXJuIGNoYW5nZShyZXN1bHQsIChzdG9yZT1JbW11dGFibGVMaXN0KCkpID0+IHN0b3JlLnNldChrZXksIHZhbHVlKSlcbiAgfVxuXG4gIFtUeXBlZC50eXBlTmFtZV0oKSB7XG4gICAgcmV0dXJuIHRoaXNbJGxhYmVsXSB8fCBgVHlwZWQuTGlzdCgke3RoaXNbJHR5cGVdWyR0eXBlTmFtZV0oKX0pYFxuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZyh0aGlzWyR0eXBlTmFtZV0oKSArICcoWycsICddKScpXG4gIH1cblxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXNbJHN0b3JlXS5oYXMoa2V5KVxuICB9XG5cbiAgZ2V0KGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzWyRzdG9yZV0gPyB0aGlzWyRzdG9yZV0uZ2V0KGluZGV4LCBub3RTZXRWYWx1ZSkgOlxuICAgICAgICAgICBub3RTZXRWYWx1ZVxuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gY2hhbmdlKHRoaXMsIGNsZWFyKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzWyRlbXB0eV0gfHwgdGhpc1skcmVhZF0oKVxuICB9XG5cbiAgcmVtb3ZlKGluZGV4KSB7XG4gICAgcmV0dXJuIGNoYW5nZSh0aGlzLCBzdG9yZSA9PiBzdG9yZSAmJiBzdG9yZS5yZW1vdmUoaW5kZXgpKVxuICB9XG5cbiAgc2V0KGluZGV4LCB2YWx1ZSkge1xuICAgIGlmIChpbmRleCA+IHRoaXMuc2l6ZSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKGBJbmRleCBcIiR7aW5kZXh9XCIgaXMgb3V0IG9mIGJvdW5kYClcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzWyR0eXBlXVskcmVhZF0odmFsdWUpXG5cbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoYEludmFsaWQgdmFsdWU6ICR7cmVzdWx0Lm1lc3NhZ2V9YClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1skc3RlcF0odGhpcywgW2luZGV4LCByZXN1bHRdKVxuICB9XG5cbiAgcHVzaCguLi52YWx1ZXMpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpc1skdHlwZV1cbiAgICBjb25zdCBpdGVtcyA9IFtdXG4gICAgY29uc3QgY291bnQgPSB2YWx1ZXMubGVuZ3RoXG4gICAgbGV0IGluZGV4ID0gMFxuICAgIHdoaWxlIChpbmRleCA8IGNvdW50KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleF1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHR5cGVbJHJlYWRdKHZhbHVlKVxuXG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZTogJHtyZXN1bHQubWVzc2FnZX1gKVxuICAgICAgfVxuXG4gICAgICBpdGVtcy5wdXNoKHJlc3VsdClcbiAgICAgIGluZGV4ID0gaW5kZXggKyAxXG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZSh0aGlzLCBzdG9yZSA9PlxuICAgICAgc3RvcmUgPyBzdG9yZS5wdXNoKC4uLml0ZW1zKSA6IEltbXV0YWJsZUxpc3QoLi4uaXRlbXMpKVxuICB9XG4gIHBvcCgpIHtcbiAgICByZXR1cm4gY2hhbmdlKHRoaXMsIHBvcClcbiAgfVxuICB1bnNoaWZ0KC4uLnZhbHVlcykge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzWyR0eXBlXVxuICAgIGNvbnN0IGl0ZW1zID0gW11cbiAgICBjb25zdCBjb3VudCA9IHZhbHVlcy5sZW5ndGhcbiAgICBsZXQgaW5kZXggPSAwXG5cbiAgICB3aGlsZSAoaW5kZXggPCBjb3VudCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdXG4gICAgICBjb25zdCByZXN1bHQgPSB0eXBlWyRyZWFkXSh2YWx1ZSlcblxuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoYEludmFsaWQgdmFsdWU6ICR7cmVzdWx0Lm1lc3NhZ2V9YClcbiAgICAgIH1cblxuICAgICAgaXRlbXMucHVzaChyZXN1bHQpXG4gICAgICBpbmRleCA9IGluZGV4ICsgMVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2UodGhpcywgc3RvcmUgPT5cbiAgICAgIHN0b3JlID8gc3RvcmUudW5zaGlmdCguLi5pdGVtcykgOiBJbW11dGFibGVMaXN0KC4uLml0ZW1zKSlcbiAgfVxuICBzaGlmdCgpIHtcbiAgICByZXR1cm4gY2hhbmdlKHRoaXMsIHNoaWZ0KVxuICB9XG4gIHNldFNpemUoc2l6ZSkge1xuICAgIGlmIChzaXplID4gdGhpcy5zaXplKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoYHNldFNpemUgbWF5IG9ubHkgZG93bnNpemVgKVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2UodGhpcywgc3RvcmUgPT4gc3RvcmUuc2V0U2l6ZShzaXplKSlcbiAgfVxuICBzbGljZShiZWdpbiwgZW5kKSB7XG4gICAgcmV0dXJuIGNoYW5nZSh0aGlzLCBzdG9yZSA9PiBzdG9yZSAmJiBzdG9yZS5zbGljZShiZWdpbiwgZW5kKSlcbiAgfVxuXG4gIHdhc0FsdGVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXNbJHN0b3JlXS53YXNBbHRlcmVkKClcbiAgfVxuXG4gIF9fZW5zdXJlT3duZXIob3duZXJJRCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX19vd25lcklEID09PSBvd25lcklEID8gdGhpcyA6XG4gICAgICAgICAgICAgICAgICAgIW93bmVySUQgPyB0aGlzIDpcbiAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3QodGhpcylcblxuICAgIHJlc3VsdC5fX293bmVySUQgPSBvd25lcklEXG4gICAgcmVzdWx0WyRzdG9yZV0gPSB0aGlzWyRzdG9yZV0gPyB0aGlzWyRzdG9yZV0uX19lbnN1cmVPd25lcihvd25lcklEKSA6XG4gICAgICAgICAgICAgICAgICAgICBJbW11dGFibGVMaXN0KCkuX19lbnN1cmVPd25lcihvd25lcklEKVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG4gIF9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSkge1xuICAgIHJldHVybiBJbmRleGVkKHRoaXNbJHN0b3JlXSkubWFwKChfLCBrZXkpID0+IHRoaXMuZ2V0KGtleSkpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSlcbiAgfVxuXG4gIF9faXRlcmF0ZShmLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIEluZGV4ZWQodGhpc1skc3RvcmVdKS5tYXAoKF8sIGtleSkgPT4gdGhpcy5nZXQoa2V5KSkuX19pdGVyYXRlKGYsIHJldmVyc2UpXG4gIH1cbn1cblR5cGVJbmZlcmVkTGlzdC5wcm90b3R5cGVbVHlwZWQuREVMRVRFXSA9IFR5cGVJbmZlcmVkTGlzdC5wcm90b3R5cGUucmVtb3ZlO1xuXG5jbGFzcyBUeXBlZExpc3QgZXh0ZW5kcyBUeXBlSW5mZXJlZExpc3Qge1xuICBjb25zdHJ1Y3RvcigpIHt9XG4gIFtUeXBlZC5pbml0XSgpIHtcbiAgICByZXR1cm4gY29uc3RydWN0KHRoaXMpLmFzTXV0YWJsZSgpXG4gIH1cbiAgW1R5cGVkLnJlc3VsdF0ocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdC5hc0ltbXV0YWJsZSgpXG4gIH1cbiAgbWFwKG1hcHBlciwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFR5cGVJbmZlcmVkTGlzdC5mcm9tKHRoaXMpLm1hcChtYXBwZXIsIGNvbnRleHQpXG4gICAgICBpZiAocmVzdWx0WyR0eXBlXSA9PT0gdGhpc1skdHlwZV0pIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IGNvbnN0cnVjdCh0aGlzKVxuICAgICAgICBsaXN0WyRzdG9yZV0gPSByZXN1bHRbJHN0b3JlXVxuICAgICAgICBsaXN0LnNpemUgPSByZXN1bHQuc2l6ZVxuICAgICAgICByZXR1cm4gbGlzdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgTGlzdCA9IGZ1bmN0aW9uKGRlc2NyaXB0b3IsIGxhYmVsKSB7XG4gIGlmIChkZXNjcmlwdG9yID09PSB2b2lkKDApKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiVHlwZWQuTGlzdCBtdXN0IGJlIHBhc3NlZCBhIHR5cGUgZGVzY3JpcHRvclwiKVxuICB9XG5cbiAgaWYgKGRlc2NyaXB0b3IgPT09IEFueSkge1xuICAgIHJldHVybiBJbW11dGFibGUuTGlzdFxuICB9XG5cbiAgY29uc3QgdHlwZSA9IHR5cGVPZihkZXNjcmlwdG9yKVxuXG4gIGlmICh0eXBlID09PSBBbnkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJUeXBlZC5MaXN0IHdhcyBwYXNzZWQgYW4gaW52YWxpZCB0eXBlIGRlc2NyaXB0b3I6ICR7ZGVzY3JpcHRvcn1cIilcbiAgfVxuXG4gIGNvbnN0IExpc3RUeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBjb25zdCBpc0xpc3RUeXBlID0gdGhpcyBpbnN0YW5jZW9mIExpc3RUeXBlXG4gICAgY29uc3QgVHlwZSA9IGlzTGlzdFR5cGUgPyB0aGlzLmNvbnN0cnVjdG9yIDogTGlzdFR5cGVcblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IFR5cGUucHJvdG90eXBlWyRyZWFkXSh2YWx1ZSlcblxuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgIHRocm93IHJlc3VsdFxuICAgIH1cblxuICAgIC8vIGBsaXN0Lm1hcChmKWAgd2lsbCBpbiBmYWN0IGNhdXNlIGBsaXN0LmNvbnN0cnVjdG9yKGl0ZW1zKWAgdG8gYmVcbiAgICAvLyBpbnZva2VkIHRoZXJlIGZvciB3ZSBuZWVkIHRvIGNoZWNrIGlmIGB0aGlzWyRzdG9yZV1gIHdhc1xuICAgIC8vIGFzc2lnbmVkIHRvIGtub3cgaWYgaXQncyB0aGF0IG9yIGlmIGl0J3MgYSBgbmV3IExpc3RUeXBlKClgIGNhbGwuXG4gICAgaWYgKGlzTGlzdFR5cGUgJiYgIXRoaXNbJHN0b3JlXSkge1xuICAgICAgdGhpc1skc3RvcmVdID0gcmVzdWx0WyRzdG9yZV1cbiAgICAgIHRoaXMuc2l6ZSA9IHJlc3VsdC5zaXplXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIExpc3RUeXBlLm9mID0gSW1tdXRhYmxlTGlzdC5vZlxuICBMaXN0VHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExpc3RQcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge3ZhbHVlOiBMaXN0VHlwZX0sXG4gICAgWyR0eXBlXToge3ZhbHVlOiB0eXBlfSxcbiAgICBbJGxhYmVsXToge3ZhbHVlOiBsYWJlbH1cbiAgfSlcblxuICByZXR1cm4gTGlzdFR5cGVcbn1cbkxpc3QuVHlwZSA9IFR5cGVkTGlzdFxuTGlzdC5wcm90b3R5cGUgPSBUeXBlZExpc3QucHJvdG90eXBlXG5jb25zdCBMaXN0UHJvdG90eXBlID0gVHlwZWRMaXN0LnByb3RvdHlwZVxuXG5cbiJdfQ==