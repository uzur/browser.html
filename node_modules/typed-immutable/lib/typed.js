(function (factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "immutable"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("immutable"));
  }
})(function (exports, _immutable) {
  "use strict";

  var _createComputedClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var prop = props[i]; prop.configurable = true; if (prop.value) prop.writable = true; Object.defineProperty(target, prop.key, prop); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

  var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

  var Immutable = _immutable;

  if (typeof Symbol === "undefined") {
    var Symbol = function (hint) {
      return "@@" + hint;
    };
    Symbol["for"] = Symbol;
  }

  function Construct() {}
  var construct = function (value) {
    Construct.prototype = value.constructor.prototype;
    return new Construct();
  };

  exports.construct = construct;
  var $type = Symbol["for"]("typed/type");
  var $store = Symbol["for"]("typed/store");
  var $empty = Symbol["for"]("typed/empty");

  var $maybe = Symbol["for"]("typed/type/maybe");
  var $default = Symbol["for"]("typed/type/default");
  var $label = Symbol["for"]("typed/type/label");

  var $init = Symbol["for"]("transducer/init");
  var $result = Symbol["for"]("transducer/result");
  var $step = Symbol["for"]("transducer/step");
  var $read = Symbol["for"]("typed/type/read");
  var $parse = Symbol["for"]("typed/type/parse");
  var $typeName = Symbol("typed/type/name");
  var $typeSignature = Symbol("typed/type/signature");

  var Typed = function Typed(label, parse, defaultValue) {
    var ValueType = (function (_Type) {
      function ValueType(defaultValue) {
        _classCallCheck(this, ValueType);

        this[$default] = defaultValue;
      }

      _inherits(ValueType, _Type);

      return ValueType;
    })(Type);

    var prototype = ValueType.prototype;
    prototype[$default] = defaultValue;
    prototype[$parse] = parse;
    prototype[$label] = label;

    var TypedValue = function TypedValue(defaultValue) {
      return defaultValue === void 0 ? prototype : new ValueType(defaultValue);
    };
    TypedValue.prototype = prototype;

    return TypedValue;
  };

  exports.Typed = Typed;
  Typed.label = $label;
  Typed.defaultValue = $default;
  Typed.read = $read;
  Typed.typeName = $typeName;
  Typed.typeSignature = $typeSignature;

  Typed.type = $type;
  Typed.store = $store;
  Typed.init = $init;
  Typed.result = $result;
  Typed.step = $step;
  Typed.DELETE = "delete";
  Typed.empty = $empty;

  var typeName = function (type) {
    return type[$typeName]();
  };
  var typeSignature = function (type) {
    return type[$typeSignature]();
  };

  var Type = exports.Type = (function () {
    function Type() {
      _classCallCheck(this, Type);
    }

    _createComputedClass(Type, [{
      key: Typed.read,
      value: function () {
        var value = arguments[0] === undefined ? this[$default] : arguments[0];

        return this[$parse](value);
      }
    }, {
      key: Typed.parse,
      value: function (value) {
        throw TypeError("Type implementation must implement \"[read.symbol]\" method");
      }
    }, {
      key: Typed.typeName,
      value: function () {
        var label = this[$label];
        var defaultValue = this[$default];
        return defaultValue === void 0 ? label : "" + label + "(" + JSON.stringify(defaultValue) + ")";
      }
    }]);

    return Type;
  })();

  var ObjectPrototype = Object.prototype;

  // Returns `true` if given `x` is a JS array.
  var isArray = Array.isArray || function (x) {
    return ObjectPrototype.toString.call(x) === "[object Array]";
  };

  // Returns `true` if given `x` is a regular expression.
  var isRegExp = function (x) {
    return ObjectPrototype.toString.call(x) === "[object RegExp]";
  };

  var typeOf = function (x) {
    var type = arguments[1] === undefined ? typeof x : arguments[1];
    return (function () {
      return x === void 0 ? x : x === null ? x : x[$read] ? x : x.prototype && x.prototype[$read] ? x.prototype : type === "number" ? new Typed.Number(x) : type === "string" ? new Typed.String(x) : type === "boolean" ? new Typed.Boolean(x) : type === "symbol" ? new Typed.Symbol(x) : isArray(x) ? Typed.Array(x) : isRegExp(x) ? new Typed.RegExp(x) : x === String ? Typed.String.prototype : x === Number ? Typed.Number.prototype : x === Boolean ? Typed.Boolean.prototype : x === RegExp ? Typed.RegExp.prototype : x === Array ? Typed.Array.prototype : x === Symbol ? Typed.Symbol.prototype : x === Date ? Typed.Date.prototype : Any;
    })();
  };

  exports.typeOf = typeOf;
  var Any = Typed("Any", function (value) {
    return value;
  })();
  exports.Any = Any;
  Typed.Any = Any;

  Typed.Number = Typed("Number", function (value) {
    return typeof value === "number" ? value : TypeError("\"" + value + "\" is not a number");
  });

  Typed.String = Typed("String", function (value) {
    return typeof value === "string" ? value : TypeError("\"" + value + "\" is not a string");
  });

  Typed.Symbol = Typed("Symbol", function (value) {
    return typeof value === "symbol" ? value : TypeError("\"" + value + "\" is not a symbol");
  });

  Typed.Array = Typed("Array", function (value) {
    return isArray(value) ? value : TypeError("\"" + value + "\" is not an array");
  });

  Typed.RegExp = Typed("RegExp", function (value) {
    return value instanceof RegExp ? value : TypeError("\"" + value + "\" is not a regexp");
  });

  Typed.Boolean = Typed("Boolean", function (value) {
    return value === true ? true : value === false ? false : TypeError("\"" + value + "\" is not a boolean");
  });

  var MaybeType = (function (_Type) {
    function MaybeType(type) {
      _classCallCheck(this, MaybeType);

      this[$type] = type;
    }

    _inherits(MaybeType, _Type);

    _createComputedClass(MaybeType, [{
      key: Typed.typeName,
      value: function () {
        return "Maybe(" + this[$type][$typeName]() + ")";
      }
    }, {
      key: Typed.read,
      value: function (value) {
        var result = value == null ? null : this[$type][$read](value);

        return !(result instanceof TypeError) ? result : TypeError("\"" + value + "\" is not nully nor it is of " + this[$type][$typeName]() + " type");
      }
    }]);

    return MaybeType;
  })(Type);

  var Maybe = function (Type) {
    var type = typeOf(Type);
    if (type === Any) {
      throw TypeError("" + Type + " is not a valid type");
    }

    return type[$maybe] || (type[$maybe] = new MaybeType(type));
  };
  exports.Maybe = Maybe;
  Maybe.Type = MaybeType;

  var UnionType = (function (_Type2) {
    function UnionType(variants) {
      _classCallCheck(this, UnionType);

      this[$type] = variants;
    }

    _inherits(UnionType, _Type2);

    _createComputedClass(UnionType, [{
      key: Typed.typeName,
      value: function () {
        return "Union(" + this[$type].map(typeName).join(", ") + ")";
      }
    }, {
      key: Typed.read,
      value: function (value) {
        var variants = this[$type];
        var count = variants.length;
        var index = 0;
        while (index < count) {
          var result = variants[index][$read](value);
          if (!(result instanceof TypeError)) {
            return result;
          }
          index = index + 1;
        }

        return TypeError("\"" + value + "\" does not satisfy " + this[$typeName]() + " type");
      }
    }]);

    return UnionType;
  })(Type);

  // Returns `xs` excluding any values that are included in `ys`.
  var subtract = function (xs, ys) {
    return xs.filter(function (x) {
      return ys.indexOf(x) < 0;
    });
  };

  // Returns array including all values from `xs` and all values from
  // `ys` that aren't already included in `xs`. It will also attempt
  // to return either `xs` or `ys` if one of them is a superset of other.
  // return `xs` or `ys` if
  var union = function (xs, ys) {
    // xs can be superset only if it contains more items then
    // ys. If that's a case find items in ys that arent included
    // in xs. If such items do not exist return back `xs` otherwise
    // return concatination of xs with those items.
    // those items
    if (xs.length > ys.length) {
      var diff = subtract(ys, xs);
      return diff.length === 0 ? xs : xs.concat(diff);
    }
    // if number of items in xs is not greater than number of items in ys
    // then either xs is either subset or equal of `ys`. There for we find
    // ys that are not included in `xs` if such items aren't found ys is
    // either superset or equal so just return ys otherwise return concatination
    // of those items with `ys`.
    else {
      var diff = subtract(xs, ys);
      return diff.length === 0 ? ys : diff.concat(ys);
    }
  };

  var Union = function () {
    for (var _len = arguments.length, Types = Array(_len), _key = 0; _key < _len; _key++) {
      Types[_key] = arguments[_key];
    }

    var count = Types.length;

    if (count === 0) {
      throw TypeError("Union must be of at at least one type");
    }

    var variants = null;
    var type = null;
    var index = 0;
    while (index < count) {
      var variant = typeOf(Types[index]);
      // If there is `Any` present than union is also `Any`.
      if (variant === Any) {
        return Any;
      }
      // If this is the first type we met than we assume it's the
      // one that satisfies all types.
      if (!variants) {
        type = variant;
        variants = type instanceof UnionType ? type[$type] : [variant];
      } else if (variants.indexOf(variant) < 0) {
        // If current reader is of union type
        if (variant instanceof UnionType) {
          var variantUnion = union(variants, variant[$type]);

          // If `reader.readers` matches union of readers, then
          // current reader is a superset so we use it as a type
          // that satisfies all types.
          if (variantUnion === variant[$type]) {
            type = variant;
            variants = variantUnion;
          }
          // If current readers is not the union than it does not
          // satisfy currenty reader. There for we update readers
          // and unset a type.
          else if (variantUnion !== variants) {
            type = null;
            variants = variantUnion;
          }
        } else {
          type = null;
          variants.push(variant);
        }
      }

      index = index + 1;
    }

    return type ? type : new UnionType(variants);
  };
  exports.Union = Union;
  Union.Type = UnionType;

  Typed.Number.Range = function (from, _x, defaultValue) {
    var to = arguments[1] === undefined ? +Infinity : arguments[1];
    return Typed("Typed.Number.Range(" + from + ".." + to + ")", function (value) {
      if (typeof value !== "number") {
        return TypeError("\"" + value + "\" is not a number");
      }

      if (!(value >= from && value <= to)) {
        return TypeError("\"" + value + "\" isn't in the range of " + from + ".." + to);
      }

      return value;
    }, defaultValue);
  };
});
//# sourceMappingURL=data:application/json;base64,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Q0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUE7U0FDdkI7T0FDRjs7QUFFRCxXQUFLLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQTtLQUNsQjs7QUFFRCxXQUFPLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUE7R0FDN0MsQ0FBQTtVQWxEWSxLQUFLLEdBQUwsS0FBSztBQW1EbEIsT0FBSyxDQUFDLElBQUksR0FBRyxTQUFTLENBQUE7O0FBR3RCLE9BQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLFVBQUMsSUFBSSxNQUFnQixZQUFZO1FBQTFCLEVBQUUsZ0NBQUMsQ0FBQyxRQUFRO1dBQ3RDLEtBQUsseUJBQXVCLElBQUksVUFBSyxFQUFFLFFBQUssVUFBQSxLQUFLLEVBQUk7QUFDbkQsVUFBSSxPQUFPLEtBQUssQUFBQyxLQUFLLFFBQVEsRUFBRTtBQUM5QixlQUFPLFNBQVMsUUFBSyxLQUFLLHdCQUFvQixDQUFBO09BQy9DOztBQUVELFVBQUksRUFBRSxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSSxFQUFFLENBQUEsQUFBQyxFQUFFO0FBQ25DLGVBQU8sU0FBUyxRQUFLLEtBQUssaUNBQTJCLElBQUksVUFBSyxFQUFFLENBQUcsQ0FBQTtPQUNwRTs7QUFFRCxhQUFPLEtBQUssQ0FBQTtLQUNiLEVBQUUsWUFBWSxDQUFDO0dBQUEsQ0FBQSIsImZpbGUiOiJzcmMvdHlwZWQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBJbW11dGFibGUgZnJvbSAnaW1tdXRhYmxlJ1xuXG5pZiAodHlwZW9mKFN5bWJvbCkgPT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBTeW1ib2wgPSBoaW50ID0+IGBAQCR7aGludH1gXG4gIFN5bWJvbC5mb3IgPSBTeW1ib2xcbn1cblxuZnVuY3Rpb24gQ29uc3RydWN0KCkge31cbmV4cG9ydCBjb25zdCBjb25zdHJ1Y3QgPSB2YWx1ZSA9PiB7XG4gIENvbnN0cnVjdC5wcm90b3R5cGUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ldyBDb25zdHJ1Y3QoKVxufVxuXG5jb25zdCAkdHlwZSA9IFN5bWJvbC5mb3IoXCJ0eXBlZC90eXBlXCIpXG5jb25zdCAkc3RvcmUgPSBTeW1ib2wuZm9yKFwidHlwZWQvc3RvcmVcIilcbmNvbnN0ICRlbXB0eSA9IFN5bWJvbC5mb3IoXCJ0eXBlZC9lbXB0eVwiKVxuXG5jb25zdCAkbWF5YmUgPSBTeW1ib2wuZm9yKFwidHlwZWQvdHlwZS9tYXliZVwiKVxuY29uc3QgJGRlZmF1bHQgPSBTeW1ib2wuZm9yKFwidHlwZWQvdHlwZS9kZWZhdWx0XCIpXG5jb25zdCAkbGFiZWwgPSBTeW1ib2wuZm9yKFwidHlwZWQvdHlwZS9sYWJlbFwiKVxuXG5jb25zdCAkaW5pdCA9IFN5bWJvbC5mb3IoXCJ0cmFuc2R1Y2VyL2luaXRcIilcbmNvbnN0ICRyZXN1bHQgPSBTeW1ib2wuZm9yKFwidHJhbnNkdWNlci9yZXN1bHRcIilcbmNvbnN0ICRzdGVwID0gU3ltYm9sLmZvcihcInRyYW5zZHVjZXIvc3RlcFwiKVxuY29uc3QgJHJlYWQgPSBTeW1ib2wuZm9yKFwidHlwZWQvdHlwZS9yZWFkXCIpXG5jb25zdCAkcGFyc2UgPSBTeW1ib2wuZm9yKFwidHlwZWQvdHlwZS9wYXJzZVwiKVxuY29uc3QgJHR5cGVOYW1lID0gU3ltYm9sKFwidHlwZWQvdHlwZS9uYW1lXCIpXG5jb25zdCAkdHlwZVNpZ25hdHVyZSA9IFN5bWJvbChcInR5cGVkL3R5cGUvc2lnbmF0dXJlXCIpXG5cbmV4cG9ydCBjb25zdCBUeXBlZCA9IGZ1bmN0aW9uKGxhYmVsLCBwYXJzZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGNsYXNzIFZhbHVlVHlwZSBleHRlbmRzIFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdGhpc1skZGVmYXVsdF0gPSBkZWZhdWx0VmFsdWVcbiAgICB9XG4gIH1cblxuICBjb25zdCBwcm90b3R5cGUgPSBWYWx1ZVR5cGUucHJvdG90eXBlXG4gIHByb3RvdHlwZVskZGVmYXVsdF0gPSBkZWZhdWx0VmFsdWVcbiAgcHJvdG90eXBlWyRwYXJzZV0gPSBwYXJzZVxuICBwcm90b3R5cGVbJGxhYmVsXSA9IGxhYmVsXG5cbiAgY29uc3QgVHlwZWRWYWx1ZSA9IGZ1bmN0aW9uKGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWUgPT09IHZvaWQoMCkgPyBwcm90b3R5cGUgOlxuICAgIG5ldyBWYWx1ZVR5cGUoZGVmYXVsdFZhbHVlKVxuICB9XG4gIFR5cGVkVmFsdWUucHJvdG90eXBlID0gcHJvdG90eXBlXG5cbiAgcmV0dXJuIFR5cGVkVmFsdWVcbn1cblxuVHlwZWQubGFiZWwgPSAkbGFiZWxcblR5cGVkLmRlZmF1bHRWYWx1ZSA9ICRkZWZhdWx0XG5UeXBlZC5yZWFkID0gJHJlYWRcblR5cGVkLnR5cGVOYW1lID0gJHR5cGVOYW1lXG5UeXBlZC50eXBlU2lnbmF0dXJlID0gJHR5cGVTaWduYXR1cmVcblxuVHlwZWQudHlwZSA9ICR0eXBlXG5UeXBlZC5zdG9yZSA9ICRzdG9yZVxuVHlwZWQuaW5pdCA9ICRpbml0XG5UeXBlZC5yZXN1bHQgPSAkcmVzdWx0XG5UeXBlZC5zdGVwID0gJHN0ZXBcblR5cGVkLkRFTEVURSA9IFwiZGVsZXRlXCJcblR5cGVkLmVtcHR5ID0gJGVtcHR5XG5cbmNvbnN0IHR5cGVOYW1lID0gdHlwZSA9PiB0eXBlWyR0eXBlTmFtZV0oKVxuY29uc3QgdHlwZVNpZ25hdHVyZSA9IHR5cGUgPT4gdHlwZVskdHlwZVNpZ25hdHVyZV0oKVxuXG5leHBvcnQgY2xhc3MgVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge31cbiAgW1R5cGVkLnJlYWRdKHZhbHVlPXRoaXNbJGRlZmF1bHRdKSB7XG4gICAgcmV0dXJuIHRoaXNbJHBhcnNlXSh2YWx1ZSlcbiAgfVxuICBbVHlwZWQucGFyc2VdKHZhbHVlKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKGBUeXBlIGltcGxlbWVudGF0aW9uIG11c3QgaW1wbGVtZW50IFwiW3JlYWQuc3ltYm9sXVwiIG1ldGhvZGApXG4gIH1cbiAgW1R5cGVkLnR5cGVOYW1lXSgpIHtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXNbJGxhYmVsXVxuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXNbJGRlZmF1bHRdXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSA9PT0gdm9pZCgwKSA/IGxhYmVsIDogYCR7bGFiZWx9KCR7SlNPTi5zdHJpbmdpZnkoZGVmYXVsdFZhbHVlKX0pYFxuICB9XG59XG5cbmNvbnN0IE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGVcblxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgZ2l2ZW4gYHhgIGlzIGEgSlMgYXJyYXkuXG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fFxuICB4ID0+IE9iamVjdFByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nXG5cbi8vIFJldHVybnMgYHRydWVgIGlmIGdpdmVuIGB4YCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbmNvbnN0IGlzUmVnRXhwID0geCA9PlxuICBPYmplY3RQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblxuXG5leHBvcnQgY29uc3QgdHlwZU9mID0gKHgsIHR5cGU9dHlwZW9mKHgpKSA9PlxuICB4ID09PSB2b2lkKDApID8geCA6XG4gIHggPT09IG51bGwgPyB4IDpcbiAgeFskcmVhZF0gPyB4IDpcbiAgKHgucHJvdG90eXBlICYmIHgucHJvdG90eXBlWyRyZWFkXSkgPyB4LnByb3RvdHlwZSA6XG4gIHR5cGUgPT09IFwibnVtYmVyXCIgPyBuZXcgVHlwZWQuTnVtYmVyKHgpIDpcbiAgdHlwZSA9PT0gXCJzdHJpbmdcIiA/IG5ldyBUeXBlZC5TdHJpbmcoeCkgOlxuICB0eXBlID09PSBcImJvb2xlYW5cIiA/IG5ldyBUeXBlZC5Cb29sZWFuKHgpIDpcbiAgdHlwZSA9PT0gXCJzeW1ib2xcIiA/IG5ldyBUeXBlZC5TeW1ib2woeCkgOlxuICBpc0FycmF5KHgpID8gVHlwZWQuQXJyYXkoeCkgOlxuICBpc1JlZ0V4cCh4KSA/IG5ldyBUeXBlZC5SZWdFeHAoeCkgOlxuICB4ID09PSBTdHJpbmcgPyBUeXBlZC5TdHJpbmcucHJvdG90eXBlIDpcbiAgeCA9PT0gTnVtYmVyID8gVHlwZWQuTnVtYmVyLnByb3RvdHlwZSA6XG4gIHggPT09IEJvb2xlYW4gPyBUeXBlZC5Cb29sZWFuLnByb3RvdHlwZSA6XG4gIHggPT09IFJlZ0V4cCA/IFR5cGVkLlJlZ0V4cC5wcm90b3R5cGUgOlxuICB4ID09PSBBcnJheSA/IFR5cGVkLkFycmF5LnByb3RvdHlwZSA6XG4gIHggPT09IFN5bWJvbCA/IFR5cGVkLlN5bWJvbC5wcm90b3R5cGUgOlxuICB4ID09PSBEYXRlID8gVHlwZWQuRGF0ZS5wcm90b3R5cGUgOlxuICBBbnk7XG5cbmV4cG9ydCBjb25zdCBBbnkgPSBUeXBlZChcIkFueVwiLCB2YWx1ZSA9PiB2YWx1ZSkoKVxuVHlwZWQuQW55ID0gQW55XG5cblR5cGVkLk51bWJlciA9IFR5cGVkKFwiTnVtYmVyXCIsIHZhbHVlID0+XG4gIHR5cGVvZih2YWx1ZSkgPT09IFwibnVtYmVyXCIgPyB2YWx1ZSA6XG4gIFR5cGVFcnJvcihgXCIke3ZhbHVlfVwiIGlzIG5vdCBhIG51bWJlcmApKVxuXG5UeXBlZC5TdHJpbmcgPSBUeXBlZChcIlN0cmluZ1wiLCB2YWx1ZSA9PlxuICB0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiID8gdmFsdWUgOlxuICBUeXBlRXJyb3IoYFwiJHt2YWx1ZX1cIiBpcyBub3QgYSBzdHJpbmdgKSlcblxuVHlwZWQuU3ltYm9sID0gVHlwZWQoXCJTeW1ib2xcIiwgdmFsdWUgPT5cbiAgdHlwZW9mKHZhbHVlKSA9PT0gXCJzeW1ib2xcIiA/IHZhbHVlIDpcbiAgVHlwZUVycm9yKGBcIiR7dmFsdWV9XCIgaXMgbm90IGEgc3ltYm9sYCkpXG5cblR5cGVkLkFycmF5ID0gVHlwZWQoXCJBcnJheVwiLCB2YWx1ZSA9PlxuICBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDpcbiAgVHlwZUVycm9yKGBcIiR7dmFsdWV9XCIgaXMgbm90IGFuIGFycmF5YCkpXG5cblR5cGVkLlJlZ0V4cCA9IFR5cGVkKFwiUmVnRXhwXCIsIHZhbHVlID0+XG4gIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwID8gdmFsdWUgOlxuICBUeXBlRXJyb3IoYFwiJHt2YWx1ZX1cIiBpcyBub3QgYSByZWdleHBgKSlcblxuVHlwZWQuQm9vbGVhbiA9IFR5cGVkKFwiQm9vbGVhblwiLCB2YWx1ZSA9PlxuICB2YWx1ZSA9PT0gdHJ1ZSA/IHRydWUgOlxuICB2YWx1ZSA9PT0gZmFsc2UgPyBmYWxzZSA6XG4gIFR5cGVFcnJvcihgXCIke3ZhbHVlfVwiIGlzIG5vdCBhIGJvb2xlYW5gKSlcblxuY2xhc3MgTWF5YmVUeXBlIGV4dGVuZHMgVHlwZSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICB0aGlzWyR0eXBlXSA9IHR5cGVcbiAgfVxuICBbVHlwZWQudHlwZU5hbWVdKCkge1xuICAgIHJldHVybiBgTWF5YmUoJHt0aGlzWyR0eXBlXVskdHlwZU5hbWVdKCl9KWBcbiAgfVxuICBbVHlwZWQucmVhZF0odmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IHRoaXNbJHR5cGVdWyRyZWFkXSh2YWx1ZSlcblxuICAgIHJldHVybiAhKHJlc3VsdCBpbnN0YW5jZW9mIFR5cGVFcnJvcikgPyByZXN1bHQgOlxuICAgICAgICAgICBUeXBlRXJyb3IoYFwiJHt2YWx1ZX1cIiBpcyBub3QgbnVsbHkgbm9yIGl0IGlzIG9mICR7dGhpc1skdHlwZV1bJHR5cGVOYW1lXSgpfSB0eXBlYClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgTWF5YmUgPSBUeXBlID0+IHtcbiAgY29uc3QgdHlwZSA9IHR5cGVPZihUeXBlKVxuICBpZiAodHlwZSA9PT0gQW55KSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKGAke1R5cGV9IGlzIG5vdCBhIHZhbGlkIHR5cGVgKVxuICB9XG5cbiAgcmV0dXJuIHR5cGVbJG1heWJlXSB8fCAodHlwZVskbWF5YmVdID0gbmV3IE1heWJlVHlwZSh0eXBlKSlcbn1cbk1heWJlLlR5cGUgPSBNYXliZVR5cGVcblxuXG5jbGFzcyBVbmlvblR5cGUgZXh0ZW5kcyBUeXBlIHtcbiAgY29uc3RydWN0b3IodmFyaWFudHMpIHtcbiAgICB0aGlzWyR0eXBlXSA9IHZhcmlhbnRzXG4gIH1cbiAgW1R5cGVkLnR5cGVOYW1lXSgpIHtcbiAgICByZXR1cm4gYFVuaW9uKCR7dGhpc1skdHlwZV0ubWFwKHR5cGVOYW1lKS5qb2luKCcsICcpfSlgXG4gIH1cbiAgW1R5cGVkLnJlYWRdKHZhbHVlKSB7XG4gICAgY29uc3QgdmFyaWFudHMgPSB0aGlzWyR0eXBlXVxuICAgIGNvbnN0IGNvdW50ID0gdmFyaWFudHMubGVuZ3RoXG4gICAgbGV0IGluZGV4ID0gMFxuICAgIHdoaWxlIChpbmRleCA8IGNvdW50KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB2YXJpYW50c1tpbmRleF1bJHJlYWRdKHZhbHVlKVxuICAgICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgVHlwZUVycm9yKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgICBpbmRleCA9IGluZGV4ICsgMVxuICAgIH1cblxuICAgIHJldHVybiBUeXBlRXJyb3IoYFwiJHt2YWx1ZX1cIiBkb2VzIG5vdCBzYXRpc2Z5ICR7dGhpc1skdHlwZU5hbWVdKCl9IHR5cGVgKVxuICB9XG59XG5cbi8vIFJldHVybnMgYHhzYCBleGNsdWRpbmcgYW55IHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBgeXNgLlxuY29uc3Qgc3VidHJhY3QgPSAoeHMsIHlzKSA9PlxuICB4cy5maWx0ZXIoeCA9PiB5cy5pbmRleE9mKHgpIDwgMClcblxuLy8gUmV0dXJucyBhcnJheSBpbmNsdWRpbmcgYWxsIHZhbHVlcyBmcm9tIGB4c2AgYW5kIGFsbCB2YWx1ZXMgZnJvbVxuLy8gYHlzYCB0aGF0IGFyZW4ndCBhbHJlYWR5IGluY2x1ZGVkIGluIGB4c2AuIEl0IHdpbGwgYWxzbyBhdHRlbXB0XG4vLyB0byByZXR1cm4gZWl0aGVyIGB4c2Agb3IgYHlzYCBpZiBvbmUgb2YgdGhlbSBpcyBhIHN1cGVyc2V0IG9mIG90aGVyLlxuLy8gcmV0dXJuIGB4c2Agb3IgYHlzYCBpZlxuY29uc3QgdW5pb24gPSAoeHMsIHlzKSA9PiB7XG4gIC8vIHhzIGNhbiBiZSBzdXBlcnNldCBvbmx5IGlmIGl0IGNvbnRhaW5zIG1vcmUgaXRlbXMgdGhlblxuICAvLyB5cy4gSWYgdGhhdCdzIGEgY2FzZSBmaW5kIGl0ZW1zIGluIHlzIHRoYXQgYXJlbnQgaW5jbHVkZWRcbiAgLy8gaW4geHMuIElmIHN1Y2ggaXRlbXMgZG8gbm90IGV4aXN0IHJldHVybiBiYWNrIGB4c2Agb3RoZXJ3aXNlXG4gIC8vIHJldHVybiBjb25jYXRpbmF0aW9uIG9mIHhzIHdpdGggdGhvc2UgaXRlbXMuXG4gIC8vIHRob3NlIGl0ZW1zXG4gIGlmICh4cy5sZW5ndGggPiB5cy5sZW5ndGgpIHtcbiAgICBjb25zdCBkaWZmID0gc3VidHJhY3QoeXMsIHhzKVxuICAgIHJldHVybiBkaWZmLmxlbmd0aCA9PT0gMCA/IHhzIDogeHMuY29uY2F0KGRpZmYpXG4gIH1cbiAgLy8gaWYgbnVtYmVyIG9mIGl0ZW1zIGluIHhzIGlzIG5vdCBncmVhdGVyIHRoYW4gbnVtYmVyIG9mIGl0ZW1zIGluIHlzXG4gIC8vIHRoZW4gZWl0aGVyIHhzIGlzIGVpdGhlciBzdWJzZXQgb3IgZXF1YWwgb2YgYHlzYC4gVGhlcmUgZm9yIHdlIGZpbmRcbiAgLy8geXMgdGhhdCBhcmUgbm90IGluY2x1ZGVkIGluIGB4c2AgaWYgc3VjaCBpdGVtcyBhcmVuJ3QgZm91bmQgeXMgaXNcbiAgLy8gZWl0aGVyIHN1cGVyc2V0IG9yIGVxdWFsIHNvIGp1c3QgcmV0dXJuIHlzIG90aGVyd2lzZSByZXR1cm4gY29uY2F0aW5hdGlvblxuICAvLyBvZiB0aG9zZSBpdGVtcyB3aXRoIGB5c2AuXG4gIGVsc2Uge1xuICAgIGNvbnN0IGRpZmYgPSBzdWJ0cmFjdCh4cywgeXMpXG4gICAgcmV0dXJuIGRpZmYubGVuZ3RoID09PSAwID8geXMgOiBkaWZmLmNvbmNhdCh5cylcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgVW5pb24gPSAoLi4uVHlwZXMpID0+IHtcbiAgY29uc3QgY291bnQgPSBUeXBlcy5sZW5ndGhcblxuICBpZiAoY291bnQgPT09IDApIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoYFVuaW9uIG11c3QgYmUgb2YgYXQgYXQgbGVhc3Qgb25lIHR5cGVgKVxuICB9XG5cbiAgbGV0IHZhcmlhbnRzID0gbnVsbFxuICBsZXQgdHlwZSA9IG51bGxcbiAgbGV0IGluZGV4ID0gMDtcbiAgd2hpbGUgKGluZGV4IDwgY291bnQpIHtcbiAgICBjb25zdCB2YXJpYW50ID0gdHlwZU9mKFR5cGVzW2luZGV4XSlcbiAgICAvLyBJZiB0aGVyZSBpcyBgQW55YCBwcmVzZW50IHRoYW4gdW5pb24gaXMgYWxzbyBgQW55YC5cbiAgICBpZiAodmFyaWFudCA9PT0gQW55KSB7XG4gICAgICByZXR1cm4gQW55XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHR5cGUgd2UgbWV0IHRoYW4gd2UgYXNzdW1lIGl0J3MgdGhlXG4gICAgLy8gb25lIHRoYXQgc2F0aXNmaWVzIGFsbCB0eXBlcy5cbiAgICBpZiAoIXZhcmlhbnRzKSB7XG4gICAgICB0eXBlID0gdmFyaWFudFxuICAgICAgdmFyaWFudHMgPSB0eXBlIGluc3RhbmNlb2YgVW5pb25UeXBlID8gdHlwZVskdHlwZV0gOiBbdmFyaWFudF1cbiAgICB9IGVsc2UgaWYgKHZhcmlhbnRzLmluZGV4T2YodmFyaWFudCkgPCAwKSB7XG4gICAgICAvLyBJZiBjdXJyZW50IHJlYWRlciBpcyBvZiB1bmlvbiB0eXBlXG4gICAgICBpZiAodmFyaWFudCBpbnN0YW5jZW9mIFVuaW9uVHlwZSkge1xuICAgICAgICBjb25zdCB2YXJpYW50VW5pb24gPSB1bmlvbih2YXJpYW50cywgdmFyaWFudFskdHlwZV0pXG5cbiAgICAgICAgLy8gSWYgYHJlYWRlci5yZWFkZXJzYCBtYXRjaGVzIHVuaW9uIG9mIHJlYWRlcnMsIHRoZW5cbiAgICAgICAgLy8gY3VycmVudCByZWFkZXIgaXMgYSBzdXBlcnNldCBzbyB3ZSB1c2UgaXQgYXMgYSB0eXBlXG4gICAgICAgIC8vIHRoYXQgc2F0aXNmaWVzIGFsbCB0eXBlcy5cbiAgICAgICAgaWYgKHZhcmlhbnRVbmlvbiA9PT0gdmFyaWFudFskdHlwZV0pIHtcbiAgICAgICAgICB0eXBlID0gdmFyaWFudFxuICAgICAgICAgIHZhcmlhbnRzID0gdmFyaWFudFVuaW9uXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgY3VycmVudCByZWFkZXJzIGlzIG5vdCB0aGUgdW5pb24gdGhhbiBpdCBkb2VzIG5vdFxuICAgICAgICAvLyBzYXRpc2Z5IGN1cnJlbnR5IHJlYWRlci4gVGhlcmUgZm9yIHdlIHVwZGF0ZSByZWFkZXJzXG4gICAgICAgIC8vIGFuZCB1bnNldCBhIHR5cGUuXG4gICAgICAgIGVsc2UgaWYgKHZhcmlhbnRVbmlvbiAhPT0gdmFyaWFudHMpIHtcbiAgICAgICAgICB0eXBlID0gbnVsbFxuICAgICAgICAgIHZhcmlhbnRzID0gdmFyaWFudFVuaW9uXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBudWxsXG4gICAgICAgIHZhcmlhbnRzLnB1c2godmFyaWFudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleCA9IGluZGV4ICsgMVxuICB9XG5cbiAgcmV0dXJuIHR5cGUgPyB0eXBlIDogbmV3IFVuaW9uVHlwZSh2YXJpYW50cylcbn1cblVuaW9uLlR5cGUgPSBVbmlvblR5cGVcblxuXG5UeXBlZC5OdW1iZXIuUmFuZ2UgPSAoZnJvbSwgdG89K0luZmluaXR5LCBkZWZhdWx0VmFsdWUpID0+XG4gIFR5cGVkKGBUeXBlZC5OdW1iZXIuUmFuZ2UoJHtmcm9tfS4uJHt0b30pYCwgdmFsdWUgPT4ge1xuICAgIGlmICh0eXBlb2YodmFsdWUpICE9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIFR5cGVFcnJvcihgXCIke3ZhbHVlfVwiIGlzIG5vdCBhIG51bWJlcmApXG4gICAgfVxuXG4gICAgaWYgKCEodmFsdWUgPj0gZnJvbSAmJiB2YWx1ZSA8PSB0bykpIHtcbiAgICAgIHJldHVybiBUeXBlRXJyb3IoYFwiJHt2YWx1ZX1cIiBpc24ndCBpbiB0aGUgcmFuZ2Ugb2YgJHtmcm9tfS4uJHt0b31gKVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZVxuICB9LCBkZWZhdWx0VmFsdWUpXG4iXX0=